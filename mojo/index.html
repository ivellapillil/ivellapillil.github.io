<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.21">
<meta name="author" content="Indukumar Vellapillil-Hari">
<title>Learn Mojo Programming Language</title>
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */

@import url("//fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700");

.imageblock {
    background-color: whitesmoke;
}

article, aside, details, figcaption, figure, footer, header, hgroup, main, nav, section, summary {
    display: block
}

audio, canvas, video {
    display: inline-block
}

audio:not([controls]) {
    display: none;
    height: 0
}

[hidden], template {
    display: none
}

script {
    display: none!important
}

html {
    font-family: sans-serif;
    -ms-text-size-adjust: 100%;
    -webkit-text-size-adjust: 100%
}

body {
    margin: 0
}

a {
    background: transparent
}

a:focus {
    outline: thin dotted
}

a:active, a:hover {
    outline: 0
}

h1 {
    font-size: 2em;
    margin: .67em 0
}

abbr[title] {
    border-bottom: 1px dotted
}

b, strong {
    font-weight: bold
}

dfn {
    font-style: italic
}

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0
}

mark {
    background: #ff0;
    color: #000
}

code, kbd, pre, samp {
    font-family: monospace;
    font-size: 1em
}

pre {
    white-space: pre-wrap
}

q {
    quotes: "\201C" "\201D" "\2018" "\2019"
}

small {
    font-size: 80%
}

sub, sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline
}

sup {
    top: -.5em
}

sub {
    bottom: -.25em
}

img {
    border: 0
}

svg:not(:root) {
    overflow: hidden
}

figure {
    margin: 0
}

fieldset {
    border: 1px solid silver;
    margin: 0 2px;
    padding: .35em .625em .75em
}

legend {
    border: 0;
    padding: 0
}

button, input, select, textarea {
    font-family: inherit;
    font-size: 100%;
    margin: 0
}

button, input {
    line-height: normal
}

button, select {
    text-transform: none
}

button, html input[type="button"], input[type="reset"], input[type="submit"] {
    -webkit-appearance: button;
    cursor: pointer
}

button[disabled], html input[disabled] {
    cursor: default
}

input[type="checkbox"], input[type="radio"] {
    box-sizing: border-box;
    padding: 0
}

input[type="search"] {
    -webkit-appearance: textfield;
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box;
    box-sizing: content-box
}

input[type="search"]::-webkit-search-cancel-button, input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none
}

button::-moz-focus-inner, input::-moz-focus-inner {
    border: 0;
    padding: 0
}

textarea {
    overflow: auto;
    vertical-align: top
}

table {
    border-collapse: collapse;
    border-spacing: 0
}

*, *:before, *:after {
    -moz-box-sizing: border-box;
    -webkit-box-sizing: border-box;
    box-sizing: border-box
}

html, body {
    font-size: 100%
}

body {
    background: #fff;
    color: rgba(0, 0, 0, .8);
    padding: 0;
    margin: 0;
    font-family: "Helvetica", sans-serif;
    font-weight: 400;
    font-style: normal;
    line-height: 1;
    position: relative;
    cursor: auto
}

a:hover {
    cursor: pointer
}

img, object, embed {
    max-width: 100%;
    height: auto
}

object, embed {
    height: 100%
}

img {
    -ms-interpolation-mode: bicubic
}

.left {
    float: left!important
}

.right {
    float: right!important
}

.text-left {
    text-align: left!important
}

.text-right {
    text-align: right!important
}

.text-center {
    text-align: center!important
}

.text-justify {
    text-align: justify!important
}

.hide {
    display: none
}

body {
    -webkit-font-smoothing: antialiased
}

img, object, svg {
    display: inline-block;
    vertical-align: middle
}

textarea {
    height: auto;
    min-height: 50px
}

select {
    width: 100%
}

.center {
    margin-left: auto;
    margin-right: auto
}

.spread {
    width: 100%
}

p.lead, .paragraph.lead>p, #preamble>.sectionbody>.paragraph:first-of-type p {
    font-size: 1.21875em;
    line-height: 1.6
}

.subheader, .admonitionblock td.content>.title, .audioblock>.title, .exampleblock>.title, .imageblock>.title, .listingblock>.title, .literalblock>.title, .stemblock>.title, .openblock>.title, .paragraph>.title, .quoteblock>.title, table.tableblock>.title, .verseblock>.title, .videoblock>.title, .dlist>.title, .olist>.title, .ulist>.title, .qlist>.title, .hdlist>.title {
    line-height: 1.45;
    color: #7a2518;
    font-weight: 400;
    margin-top: 0;
    margin-bottom: .25em
}

div, dl, dt, dd, ul, ol, li, h1, h2, h3, #toctitle, .sidebarblock>.content>.title, h4, h5, h6, pre, form, p, blockquote, th, td {
    margin: 0;
    padding: 0;
    direction: ltr
}

a {
    color: #2156a5;
    text-decoration: underline;
    line-height: inherit
}

a:hover, a:focus {
    color: #1d4b8f
}

a img {
    border: none
}

p {
    font-family: inherit;
    font-weight: 400;
    font-size: 1em;
    line-height: 1.6;
    margin-bottom: 1.25em;
    text-rendering: optimizeLegibility
}

p aside {
    font-size: .875em;
    line-height: 1.35;
    font-style: italic
}

h1, h2, h3, #toctitle, .sidebarblock>.content>.title, h4, h5, h6 {
    font-family: "Open Sans", "DejaVu Sans", sans-serif;
    font-weight: 300;
    font-style: normal;
    color: #4B0082;
    text-rendering: optimizeLegibility;
    margin-top: 1em;
    margin-bottom: .5em;
    line-height: 1.0125em
}

h1 small, h2 small, h3 small, #toctitle small, .sidebarblock>.content>.title small, h4 small, h5 small, h6 small {
    font-size: 60%;
    color: #e99b8f;
    line-height: 0
}

h1 {
    font-size: 2.125em
}

h2 {
    font-size: 1.6875em
}

h3, #toctitle, .sidebarblock>.content>.title {
    font-size: 1.375em
}

h4, h5 {
    font-size: 1.125em
}

h6 {
    font-size: 1em
}

hr {
    border: solid #ddddd8;
    border-width: 1px 0 0;
    clear: both;
    margin: 1.25em 0 1.1875em;
    height: 0
}

em, i {
    font-style: italic;
    line-height: inherit
}

strong, b {
    font-weight: bold;
    line-height: inherit
}

small {
    font-size: 60%;
    line-height: inherit
}

code {
    font-family: "Droid Sans Mono", "DejaVu Sans Mono", monospace;
    font-weight: 400;
    color: rgba(0, 0, 0, .9)
}

ul, ol, dl {
    font-size: 1em;
    line-height: 1.6;
    margin-bottom: 1.25em;
    list-style-position: outside;
    font-family: inherit
}

ul, ol, ul.no-bullet, ol.no-bullet {
    margin-left: 1.5em
}

ul li ul, ul li ol {
    margin-left: 1.25em;
    margin-bottom: 0;
    font-size: 1em
}

ul.square li ul, ul.circle li ul, ul.disc li ul {
    list-style: inherit
}

ul.square {
    list-style-type: square
}

ul.circle {
    list-style-type: circle
}

ul.disc {
    list-style-type: disc
}

ul.no-bullet {
    list-style: none
}

ol li ul, ol li ol {
    margin-left: 1.25em;
    margin-bottom: 0
}

dl dt {
    margin-bottom: .3125em;
    font-weight: bold
}

dl dd {
    margin-bottom: 1.25em
}

abbr, acronym {
    text-transform: uppercase;
    font-size: 90%;
    color: rgba(0, 0, 0, .8);
    border-bottom: 1px dotted #ddd;
    cursor: help
}

abbr {
    text-transform: none
}

blockquote {
    margin: 0 0 1.25em;
    padding: .5625em 1.25em 0 1.1875em;
    border-left: 1px solid #ddd
}

blockquote cite {
    display: block;
    font-size: .9375em;
    color: rgba(0, 0, 0, .6)
}

blockquote cite:before {
    content: "\2014 \0020"
}

blockquote cite a, blockquote cite a:visited {
    color: rgba(0, 0, 0, .6)
}

blockquote, blockquote p {
    line-height: 1.6;
    color: rgba(0, 0, 0, .85)
}

@media only screen and (min-width:768px) {
    h1, h2, h3, #toctitle, .sidebarblock>.content>.title, h4, h5, h6 {
        line-height: 1.2
    }
    h1 {
        font-size: 2.75em
    }
    h2 {
        font-size: 2.3125em
    }
    h3, #toctitle, .sidebarblock>.content>.title {
        font-size: 1.6875em
    }
    h4 {
        font-size: 1.4375em
    }
}

table {
    background: #fff;
    margin-bottom: 1.25em;
    border: solid 1px #dedede
}

table thead, table tfoot {
    background: #f7f8f7;
    font-weight: bold
}

table thead tr th, table thead tr td, table tfoot tr th, table tfoot tr td {
    padding: .5em .625em .625em;
    font-size: inherit;
    color: rgba(0, 0, 0, .8);
    text-align: left
}

table tr th, table tr td {
    padding: .5625em .625em;
    font-size: inherit;
    color: rgba(0, 0, 0, .8)
}

table tr.even, table tr.alt, table tr:nth-of-type(even) {
    background: #f8f8f7
}

table thead tr th, table tfoot tr th, table tbody tr td, table tr td, table tfoot tr td {
    display: table-cell;
    line-height: 1.6
}

body {
    tab-size: 4
}

h1, h2, h3, #toctitle, .sidebarblock>.content>.title, h4, h5, h6 {
    line-height: 1.2;
    word-spacing: -.05em
}

h1 strong, h2 strong, h3 strong, #toctitle strong, .sidebarblock>.content>.title strong, h4 strong, h5 strong, h6 strong {
    font-weight: 400
}

.clearfix:before, .clearfix:after, .float-group:before, .float-group:after {
    content: " ";
    display: table
}

.clearfix:after, .float-group:after {
    clear: both
}

*:not(pre)>code {
    font-size: .9375em;
    font-style: normal!important;
    letter-spacing: 0;
    padding: .1em .5ex;
    word-spacing: -.15em;
    background-color: #f7f7f8;
    -webkit-border-radius: 4px;
    border-radius: 4px;
    line-height: 1.45;
    text-rendering: optimizeSpeed
}

pre, pre>code {
    line-height: 1.45;
    color: rgba(0, 0, 0, .9);
    font-family: "Droid Sans Mono", "DejaVu Sans Mono", monospace;
    font-weight: 400;
    text-rendering: optimizeSpeed
}

.keyseq {
    color: rgba(51, 51, 51, .8)
}

kbd {
    font-family: "Droid Sans Mono", "DejaVu Sans Mono", monospace;
    display: inline-block;
    color: rgba(0, 0, 0, .8);
    font-size: .65em;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 1px solid #ccc;
    -webkit-border-radius: 3px;
    border-radius: 3px;
    -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, .2), 0 0 0 .1em white inset;
    box-shadow: 0 1px 0 rgba(0, 0, 0, .2), 0 0 0 .1em #fff inset;
    margin: 0 .15em;
    padding: .2em .5em;
    vertical-align: middle;
    position: relative;
    top: -.1em;
    white-space: nowrap
}

.keyseq kbd:first-child {
    margin-left: 0
}

.keyseq kbd:last-child {
    margin-right: 0
}

.menuseq, .menu {
    color: rgba(0, 0, 0, .8)
}

b.button:before, b.button:after {
    position: relative;
    top: -1px;
    font-weight: 400
}

b.button:before {
    content: "[";
    padding: 0 3px 0 2px
}

b.button:after {
    content: "]";
    padding: 0 2px 0 3px
}

p a>code:hover {
    color: rgba(0, 0, 0, .9)
}

#header, #content, #footnotes, #footer {
    width: 100%;
    margin-left: auto;
    margin-right: auto;
    margin-top: 0;
    margin-bottom: 0;
    max-width: 62.5em;
    *zoom: 1;
    position: relative;
    padding-left: .9375em;
    padding-right: .9375em
}

#header:before, #header:after, #content:before, #content:after, #footnotes:before, #footnotes:after, #footer:before, #footer:after {
    content: " ";
    display: table
}

#header:after, #content:after, #footnotes:after, #footer:after {
    clear: both
}

#content {
    margin-top: 1.25em
}

#content:before {
    content: none
}

#header>h1:first-child {
    color: rgba(0, 0, 0, .85);
    margin-top: 2.25rem;
    margin-bottom: 0
}

#header>h1:first-child+#toc {
    margin-top: 8px;
    border-top: 1px solid #ddddd8
}

#header>h1:only-child, body.toc2 #header>h1:nth-last-child(2) {
    border-bottom: 1px solid #ddddd8;
    padding-bottom: 8px
}

#header .details {
    border-bottom: 1px solid #ddddd8;
    line-height: 1.45;
    padding-top: .25em;
    padding-bottom: .25em;
    padding-left: .25em;
    color: rgba(0, 0, 0, .6);
    display: -ms-flexbox;
    display: -webkit-flex;
    display: flex;
    -ms-flex-flow: row wrap;
    -webkit-flex-flow: row wrap;
    flex-flow: row wrap
}

#header .details span:first-child {
    margin-left: -.125em
}

#header .details span.email a {
    color: rgba(0, 0, 0, .85)
}

#header .details br {
    display: none
}

#header .details br+span:before {
    content: "\00a0\2013\00a0"
}

#header .details br+span.author:before {
    content: "\00a0\22c5\00a0";
    color: rgba(0, 0, 0, .85)
}

#header .details br+span#revremark:before {
    content: "\00a0|\00a0"
}

#header #revnumber {
    text-transform: capitalize
}

#header #revnumber:after {
    content: "\00a0"
}

#content>h1:first-child:not([class]) {
    color: rgba(0, 0, 0, .85);
    border-bottom: 1px solid #ddddd8;
    padding-bottom: 8px;
    margin-top: 0;
    padding-top: 1rem;
    margin-bottom: 1.25rem
}

#toc {
    border-bottom: 1px solid #efefed;
    padding-bottom: .5em
}

#toc>ul {
    margin-left: .125em
}

#toc ul.sectlevel0>li>a {
    font-style: italic
}

#toc ul.sectlevel0 ul.sectlevel1 {
    margin: .5em 0
}

#toc ul {
    font-family: "Open Sans", "DejaVu Sans", sans-serif;
    list-style-type: none
}

#toc li {
    line-height: 1.3334;
    margin-top: .3334em
}

#toc a {
    text-decoration: none
}

#toc a:active {
    text-decoration: underline
}

#toctitle {
    color: #7a2518;
    font-size: 1.2em
}

@media only screen and (min-width:768px) {
    #toctitle {
        font-size: 1.375em
    }
    body.toc2 {
        padding-left: 15em;
        padding-right: 0
    }
    #toc.toc2 {
        margin-top: 0!important;
        background-color: #f8f8f7;
        position: fixed;
        width: 15em;
        left: 0;
        top: 0;
        border-right: 1px solid #efefed;
        border-top-width: 0!important;
        border-bottom-width: 0!important;
        z-index: 1000;
        padding: 1.25em 1em;
        height: 100%;
        overflow: auto
    }
    #toc.toc2 #toctitle {
        margin-top: 0;
        margin-bottom: .8rem;
        font-size: 1.2em
    }
    #toc.toc2>ul {
        font-size: .9em;
        margin-bottom: 0
    }
    #toc.toc2 ul ul {
        margin-left: 0;
        padding-left: 1em
    }
    #toc.toc2 ul.sectlevel0 ul.sectlevel1 {
        padding-left: 0;
        margin-top: .5em;
        margin-bottom: .5em
    }
    body.toc2.toc-right {
        padding-left: 0;
        padding-right: 15em
    }
    body.toc2.toc-right #toc.toc2 {
        border-right-width: 0;
        border-left: 1px solid #efefed;
        left: auto;
        right: 0
    }
}

@media only screen and (min-width:1280px) {
    body.toc2 {
        padding-left: 20em;
        padding-right: 0
    }
    #toc.toc2 {
        width: 20em
    }
    #toc.toc2 #toctitle {
        font-size: 1.375em
    }
    #toc.toc2>ul {
        font-size: .95em
    }
    #toc.toc2 ul ul {
        padding-left: 1.25em
    }
    body.toc2.toc-right {
        padding-left: 0;
        padding-right: 20em
    }
}

#content #toc {
    border-style: solid;
    border-width: 1px;
    border-color: #e0e0dc;
    margin-bottom: 1.25em;
    padding: 1.25em;
    background: #f8f8f7;
    -webkit-border-radius: 4px;
    border-radius: 4px
}

#content #toc>:first-child {
    margin-top: 0
}

#content #toc>:last-child {
    margin-bottom: 0
}

#footer {
    max-width: 100%;
    background-color: rgba(0, 0, 0, .8);
    padding: 1.25em
}

#footer-text {
    color: rgba(255, 255, 255, .8);
    line-height: 1.44
}

.sect1 {
    padding-bottom: .625em
}

@media only screen and (min-width:768px) {
    .sect1 {
        padding-bottom: 1.25em
    }
}

.sect1+.sect1 {
    border-top: 1px solid #efefed
}

#content h1>a.anchor, h2>a.anchor, h3>a.anchor, #toctitle>a.anchor, .sidebarblock>.content>.title>a.anchor, h4>a.anchor, h5>a.anchor, h6>a.anchor {
    position: absolute;
    z-index: 1001;
    width: 1.5ex;
    margin-left: -1.5ex;
    display: block;
    text-decoration: none!important;
    visibility: hidden;
    text-align: center;
    font-weight: 400
}

#content h1>a.anchor:before, h2>a.anchor:before, h3>a.anchor:before, #toctitle>a.anchor:before, .sidebarblock>.content>.title>a.anchor:before, h4>a.anchor:before, h5>a.anchor:before, h6>a.anchor:before {
    content: "\00A7";
    font-size: .85em;
    display: block;
    padding-top: .1em
}

#content h1:hover>a.anchor, #content h1>a.anchor:hover, h2:hover>a.anchor, h2>a.anchor:hover, h3:hover>a.anchor, #toctitle:hover>a.anchor, .sidebarblock>.content>.title:hover>a.anchor, h3>a.anchor:hover, #toctitle>a.anchor:hover, .sidebarblock>.content>.title>a.anchor:hover, h4:hover>a.anchor, h4>a.anchor:hover, h5:hover>a.anchor, h5>a.anchor:hover, h6:hover>a.anchor, h6>a.anchor:hover {
    visibility: visible
}

#content h1>a.link, h2>a.link, h3>a.link, #toctitle>a.link, .sidebarblock>.content>.title>a.link, h4>a.link, h5>a.link, h6>a.link {
    color: #ba3925;
    text-decoration: none
}

#content h1>a.link:hover, h2>a.link:hover, h3>a.link:hover, #toctitle>a.link:hover, .sidebarblock>.content>.title>a.link:hover, h4>a.link:hover, h5>a.link:hover, h6>a.link:hover {
    color: #a53221
}

.audioblock, .imageblock, .literalblock, .listingblock, .stemblock, .videoblock {
    margin-bottom: 1.25em
}

.admonitionblock td.content>.title, .audioblock>.title, .exampleblock>.title, .imageblock>.title, .listingblock>.title, .literalblock>.title, .stemblock>.title, .openblock>.title, .paragraph>.title, .quoteblock>.title, table.tableblock>.title, .verseblock>.title, .videoblock>.title, .dlist>.title, .olist>.title, .ulist>.title, .qlist>.title, .hdlist>.title {
    text-rendering: optimizeLegibility;
    text-align: left;
    font-family: "Noto Serif", "DejaVu Serif", serif;
    font-size: 1rem;
    font-style: italic
}

table.tableblock>caption.title {
    white-space: nowrap;
    overflow: visible;
    max-width: 0
}

.paragraph.lead>p, #preamble>.sectionbody>.paragraph:first-of-type p {
    color: rgba(0, 0, 0, .85)
}

table.tableblock #preamble>.sectionbody>.paragraph:first-of-type p {
    font-size: inherit
}

.admonitionblock>table {
    border-collapse: separate;
    border: 0;
    background: none;
    width: 100%
}

.admonitionblock>table td.icon {
    text-align: center;
    width: 80px
}

.admonitionblock>table td.icon img {
    max-width: none
}

.admonitionblock>table td.icon .title {
    font-weight: bold;
    font-family: "Open Sans", "DejaVu Sans", sans-serif;
    text-transform: uppercase
}

.admonitionblock>table td.content {
    padding-left: 1.125em;
    padding-right: 1.25em;
    border-left: 1px solid #ddddd8;
    color: rgba(0, 0, 0, .6)
}

.admonitionblock>table td.content>:last-child>:last-child {
    margin-bottom: 0
}

.exampleblock>.content {
    border-style: solid;
    border-width: 1px;
    border-color: #e6e6e6;
    margin-bottom: 1.25em;
    padding: 1.25em;
    background: #fff;
    -webkit-border-radius: 4px;
    border-radius: 4px
}

.exampleblock>.content>:first-child {
    margin-top: 0
}

.exampleblock>.content>:last-child {
    margin-bottom: 0
}

.sidebarblock {
    border-style: solid;
    border-width: 1px;
    border-color: #e0e0dc;
    margin-bottom: 1.25em;
    padding: 1.25em;
    background: #f8f8f7;
    -webkit-border-radius: 4px;
    border-radius: 4px
}

.sidebarblock>:first-child {
    margin-top: 0
}

.sidebarblock>:last-child {
    margin-bottom: 0
}

.sidebarblock>.content>.title {
    color: #7a2518;
    margin-top: 0;
    text-align: center
}

.exampleblock>.content>:last-child>:last-child, .exampleblock>.content .olist>ol>li:last-child>:last-child, .exampleblock>.content .ulist>ul>li:last-child>:last-child, .exampleblock>.content .qlist>ol>li:last-child>:last-child, .sidebarblock>.content>:last-child>:last-child, .sidebarblock>.content .olist>ol>li:last-child>:last-child, .sidebarblock>.content .ulist>ul>li:last-child>:last-child, .sidebarblock>.content .qlist>ol>li:last-child>:last-child {
    margin-bottom: 0
}

.literalblock pre, .listingblock pre:not(.highlight), .listingblock pre[class="highlight"], .listingblock pre[class^="highlight "], .listingblock pre.CodeRay, .listingblock pre.prettyprint {
    background: #f7f7f8
}

.sidebarblock .literalblock pre, .sidebarblock .listingblock pre:not(.highlight), .sidebarblock .listingblock pre[class="highlight"], .sidebarblock .listingblock pre[class^="highlight "], .sidebarblock .listingblock pre.CodeRay, .sidebarblock .listingblock pre.prettyprint {
    background: #f2f1f1
}

.literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] {
    -webkit-border-radius: 4px;
    border-radius: 4px;
    word-wrap: break-word;
    padding: 1em;
    font-size: .8125em
}

.literalblock pre.nowrap, .literalblock pre[class].nowrap, .listingblock pre.nowrap, .listingblock pre[class].nowrap {
    overflow-x: auto;
    white-space: pre;
    word-wrap: normal
}

@media only screen and (min-width:768px) {
    .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] {
        font-size: .90625em
    }
}

@media only screen and (min-width:1280px) {
    .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] {
        font-size: 1em
    }
}

.literalblock.output pre {
    color: #f7f7f8;
    background-color: rgba(0, 0, 0, .9)
}

.listingblock pre.highlightjs {
    padding: 0
}

.listingblock pre.highlightjs>code {
    padding: 1em;
    -webkit-border-radius: 4px;
    border-radius: 4px
}

.listingblock pre.prettyprint {
    border-width: 0
}

.listingblock>.content {
    position: relative
}

.listingblock code[data-lang]:before {
    display: none;
    content: attr(data-lang);
    position: absolute;
    font-size: .75em;
    top: .425rem;
    right: .5rem;
    line-height: 1;
    text-transform: uppercase;
    color: #999
}

.listingblock:hover code[data-lang]:before {
    display: block
}

.listingblock.terminal pre .command:before {
    content: attr(data-prompt);
    padding-right: .5em;
    color: #999
}

.listingblock.terminal pre .command:not([data-prompt]):before {
    content: "$"
}

table.pyhltable {
    border-collapse: separate;
    border: 0;
    margin-bottom: 0;
    background: none
}

table.pyhltable td {
    vertical-align: top;
    padding-top: 0;
    padding-bottom: 0;
    line-height: 1.45
}

table.pyhltable td.code {
    padding-left: .75em;
    padding-right: 0
}

pre.pygments .lineno, table.pyhltable td:not(.code) {
    color: #999;
    padding-left: 0;
    padding-right: .5em;
    border-right: 1px solid #ddddd8
}

pre.pygments .lineno {
    display: inline-block;
    margin-right: .25em
}

table.pyhltable .linenodiv {
    background: none!important;
    padding-right: 0!important
}

.quoteblock {
    margin: 0 1em 1.25em 1.5em;
    display: table
}

.quoteblock>.title {
    margin-left: -1.5em;
    margin-bottom: .75em
}

.quoteblock blockquote, .quoteblock blockquote p {
    color: rgba(0, 0, 0, .85);
    font-size: 1.15rem;
    line-height: 1.75;
    word-spacing: .1em;
    letter-spacing: 0;
    font-style: italic;
    text-align: justify
}

.quoteblock blockquote {
    margin: 0;
    padding: 0;
    border: 0
}

.quoteblock blockquote:before {
    content: "\201c";
    float: left;
    font-size: 2.75em;
    font-weight: bold;
    line-height: .6em;
    margin-left: -.6em;
    color: #7a2518;
    text-shadow: 0 1px 2px rgba(0, 0, 0, .1)
}

.quoteblock blockquote>.paragraph:last-child p {
    margin-bottom: 0
}

.quoteblock .attribution {
    margin-top: .5em;
    margin-right: .5ex;
    text-align: right
}

.quoteblock .quoteblock {
    margin-left: 0;
    margin-right: 0;
    padding: .5em 0;
    border-left: 3px solid rgba(0, 0, 0, .6)
}

.quoteblock .quoteblock blockquote {
    padding: 0 0 0 .75em
}

.quoteblock .quoteblock blockquote:before {
    display: none
}

.verseblock {
    margin: 0 1em 1.25em 1em
}

.verseblock pre {
    font-family: "Open Sans", "DejaVu Sans", sans;
    font-size: 1.15rem;
    color: rgba(0, 0, 0, .85);
    font-weight: 300;
    text-rendering: optimizeLegibility
}

.verseblock pre strong {
    font-weight: 400
}

.verseblock .attribution {
    margin-top: 1.25rem;
    margin-left: .5ex
}

.quoteblock .attribution, .verseblock .attribution {
    font-size: .9375em;
    line-height: 1.45;
    font-style: italic
}

.quoteblock .attribution br, .verseblock .attribution br {
    display: none
}

.quoteblock .attribution cite, .verseblock .attribution cite {
    display: block;
    letter-spacing: -.025em;
    color: rgba(0, 0, 0, .6)
}

.quoteblock.abstract {
    margin: 0 0 1.25em 0;
    display: block
}

.quoteblock.abstract blockquote, .quoteblock.abstract blockquote p {
    text-align: left;
    word-spacing: 0
}

.quoteblock.abstract blockquote:before, .quoteblock.abstract blockquote p:first-of-type:before {
    display: none
}

table.tableblock {
    max-width: 100%;
    border-collapse: separate
}

table.tableblock td>.paragraph:last-child p>p:last-child, table.tableblock th>p:last-child, table.tableblock td>p:last-child {
    margin-bottom: 0
}

table.tableblock, th.tableblock, td.tableblock {
    border: 0 solid #dedede
}

table.grid-all th.tableblock, table.grid-all td.tableblock {
    border-width: 0 1px 1px 0
}

table.grid-all tfoot>tr>th.tableblock, table.grid-all tfoot>tr>td.tableblock {
    border-width: 1px 1px 0 0
}

table.grid-cols th.tableblock, table.grid-cols td.tableblock {
    border-width: 0 1px 0 0
}

table.grid-all *>tr>.tableblock:last-child, table.grid-cols *>tr>.tableblock:last-child {
    border-right-width: 0
}

table.grid-rows th.tableblock, table.grid-rows td.tableblock {
    border-width: 0 0 1px 0
}

table.grid-all tbody>tr:last-child>th.tableblock, table.grid-all tbody>tr:last-child>td.tableblock, table.grid-all thead:last-child>tr>th.tableblock, table.grid-rows tbody>tr:last-child>th.tableblock, table.grid-rows tbody>tr:last-child>td.tableblock, table.grid-rows thead:last-child>tr>th.tableblock {
    border-bottom-width: 0
}

table.grid-rows tfoot>tr>th.tableblock, table.grid-rows tfoot>tr>td.tableblock {
    border-width: 1px 0 0 0
}

table.frame-all {
    border-width: 1px
}

table.frame-sides {
    border-width: 0 1px
}

table.frame-topbot {
    border-width: 1px 0
}

th.halign-left, td.halign-left {
    text-align: left
}

th.halign-right, td.halign-right {
    text-align: right
}

th.halign-center, td.halign-center {
    text-align: center
}

th.valign-top, td.valign-top {
    vertical-align: top
}

th.valign-bottom, td.valign-bottom {
    vertical-align: bottom
}

th.valign-middle, td.valign-middle {
    vertical-align: middle
}

table thead th, table tfoot th {
    font-weight: bold
}

tbody tr th {
    display: table-cell;
    line-height: 1.6;
    background: #f7f8f7
}

tbody tr th, tbody tr th p, tfoot tr th, tfoot tr th p {
    color: rgba(0, 0, 0, .8);
    font-weight: bold
}

p.tableblock>code:only-child {
    background: none;
    padding: 0
}

p.tableblock {
    font-size: 1em
}

td>div.verse {
    white-space: pre
}

ol {
    margin-left: 1.75em
}

ul li ol {
    margin-left: 1.5em
}

dl dd {
    margin-left: 1.125em
}

dl dd:last-child, dl dd:last-child>:last-child {
    margin-bottom: 0
}

ol>li p, ul>li p, ul dd, ol dd, .olist .olist, .ulist .ulist, .ulist .olist, .olist .ulist {
    margin-bottom: .625em
}

ul.unstyled, ol.unnumbered, ul.checklist, ul.none {
    list-style-type: none
}

ul.unstyled, ol.unnumbered, ul.checklist {
    margin-left: .625em
}

ul.checklist li>p:first-child>.fa-square-o:first-child, ul.checklist li>p:first-child>.fa-check-square-o:first-child {
    width: 1em;
    font-size: .85em
}

ul.checklist li>p:first-child>input[type="checkbox"]:first-child {
    width: 1em;
    position: relative;
    top: 1px
}

ul.inline {
    margin: 0 auto .625em auto;
    margin-left: -1.375em;
    margin-right: 0;
    padding: 0;
    list-style: none;
    overflow: hidden
}

ul.inline>li {
    list-style: none;
    float: left;
    margin-left: 1.375em;
    display: block
}

ul.inline>li>* {
    display: block
}

.unstyled dl dt {
    font-weight: 400;
    font-style: normal
}

ol.arabic {
    list-style-type: decimal
}

ol.decimal {
    list-style-type: decimal-leading-zero
}

ol.loweralpha {
    list-style-type: lower-alpha
}

ol.upperalpha {
    list-style-type: upper-alpha
}

ol.lowerroman {
    list-style-type: lower-roman
}

ol.upperroman {
    list-style-type: upper-roman
}

ol.lowergreek {
    list-style-type: lower-greek
}

.hdlist>table, .colist>table {
    border: 0;
    background: none
}

.hdlist>table>tbody>tr, .colist>table>tbody>tr {
    background: none
}

td.hdlist1, td.hdlist2 {
    vertical-align: top;
    padding: 0 .625em
}

td.hdlist1 {
    font-weight: bold;
    padding-bottom: 1.25em
}

.literalblock+.colist, .listingblock+.colist {
    margin-top: -.5em
}

.colist>table tr>td:first-of-type {
    padding: 0 .75em;
    line-height: 1
}

.colist>table tr>td:last-of-type {
    padding: .25em 0
}

.thumb, .th {
    line-height: 0;
    display: inline-block;
    border: solid 4px #fff;
    -webkit-box-shadow: 0 0 0 1px #ddd;
    box-shadow: 0 0 0 1px #ddd
}

.imageblock.left, .imageblock[style*="float: left"] {
    margin: .25em .625em 1.25em 0
}

.imageblock.right, .imageblock[style*="float: right"] {
    margin: .25em 0 1.25em .625em
}

.imageblock>.title {
    margin-bottom: 0
}

.imageblock.thumb, .imageblock.th {
    border-width: 6px
}

.imageblock.thumb>.title, .imageblock.th>.title {
    padding: 0 .125em
}

.image.left, .image.right {
    margin-top: .25em;
    margin-bottom: .25em;
    display: inline-block;
    line-height: 0
}

.image.left {
    margin-right: .625em
}

.image.right {
    margin-left: .625em
}

a.image {
    text-decoration: none;
    display: inline-block
}

a.image object {
    pointer-events: none
}

sup.footnote, sup.footnoteref {
    font-size: .875em;
    position: static;
    vertical-align: super
}

sup.footnote a, sup.footnoteref a {
    text-decoration: none
}

sup.footnote a:active, sup.footnoteref a:active {
    text-decoration: underline
}

#footnotes {
    padding-top: .75em;
    padding-bottom: .75em;
    margin-bottom: .625em
}

#footnotes hr {
    width: 20%;
    min-width: 6.25em;
    margin: -.25em 0 .75em 0;
    border-width: 1px 0 0 0
}

#footnotes .footnote {
    padding: 0 .375em 0 .225em;
    line-height: 1.3334;
    font-size: .875em;
    margin-left: 1.2em;
    text-indent: -1.05em;
    margin-bottom: .2em
}

#footnotes .footnote a:first-of-type {
    font-weight: bold;
    text-decoration: none
}

#footnotes .footnote:last-of-type {
    margin-bottom: 0
}

#content #footnotes {
    margin-top: -.625em;
    margin-bottom: 0;
    padding: .75em 0
}

.gist .file-data>table {
    border: 0;
    background: #fff;
    width: 100%;
    margin-bottom: 0
}

.gist .file-data>table td.line-data {
    width: 99%
}

div.unbreakable {
    page-break-inside: avoid
}

.big {
    font-size: larger
}

.small {
    font-size: smaller
}

.underline {
    text-decoration: underline
}

.overline {
    text-decoration: overline
}

.line-through {
    text-decoration: line-through
}

.aqua {
    color: #00bfbf
}

.aqua-background {
    background-color: #00fafa
}

.black {
    color: #000
}

.black-background {
    background-color: #000
}

.blue {
    color: #0000bf
}

.blue-background {
    background-color: #0000fa
}

.fuchsia {
    color: #bf00bf
}

.fuchsia-background {
    background-color: #fa00fa
}

.gray {
    color: #606060
}

.gray-background {
    background-color: #7d7d7d
}

.green {
    color: #006000
}

.green-background {
    background-color: #007d00
}

.lime {
    color: #00bf00
}

.lime-background {
    background-color: #00fa00
}

.maroon {
    color: #600000
}

.maroon-background {
    background-color: #7d0000
}

.navy {
    color: #000060
}

.navy-background {
    background-color: #00007d
}

.olive {
    color: #606000
}

.olive-background {
    background-color: #7d7d00
}

.purple {
    color: #600060
}

.purple-background {
    background-color: #7d007d
}

.red {
    color: #bf0000
}

.red-background {
    background-color: #fa0000
}

.silver {
    color: #909090
}

.silver-background {
    background-color: #bcbcbc
}

.teal {
    color: #006060
}

.teal-background {
    background-color: #007d7d
}

.white {
    color: #bfbfbf
}

.white-background {
    background-color: #fafafa
}

.yellow {
    color: #bfbf00
}

.yellow-background {
    background-color: #fafa00
}

span.icon>.fa {
    cursor: default
}

.admonitionblock td.icon [class^="fa icon-"] {
    font-size: 2.5em;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, .5);
    cursor: default
}

.admonitionblock td.icon .icon-note:before {
    content: "\f05a";
    color: #19407c
}

.admonitionblock td.icon .icon-tip:before {
    content: "\f0eb";
    text-shadow: 1px 1px 2px rgba(155, 155, 0, .8);
    color: #111
}

.admonitionblock td.icon .icon-warning:before {
    content: "\f071";
    color: #bf6900
}

.admonitionblock td.icon .icon-caution:before {
    content: "\f06d";
    color: #bf3400
}

.admonitionblock td.icon .icon-important:before {
    content: "\f06a";
    color: #bf0000
}

.conum[data-value] {
    display: inline-block;
    color: #fff!important;
    background-color: rgba(0, 0, 0, .8);
    -webkit-border-radius: 100px;
    border-radius: 100px;
    text-align: center;
    font-size: .75em;
    width: 1.67em;
    height: 1.67em;
    line-height: 1.67em;
    font-family: "Open Sans", "DejaVu Sans", sans-serif;
    font-style: normal;
    font-weight: bold
}

.conum[data-value] * {
    color: #fff!important
}

.conum[data-value]+b {
    display: none
}

.conum[data-value]:after {
    content: attr(data-value)
}

pre .conum[data-value] {
    position: relative;
    top: -.125em
}

b.conum * {
    color: inherit!important
}

.conum:not([data-value]):empty {
    display: none
}

dt, th.tableblock, td.content, div.footnote {
    text-rendering: optimizeLegibility
}

h1, h2, p, td.content, span.alt {
    letter-spacing: -.01em
}

p strong, td.content strong, div.footnote strong {
    letter-spacing: -.005em
}

p, blockquote, dt, td.content, span.alt {
    font-size: 1.0625rem
}

p {
    margin-bottom: 1.25rem
}

.sidebarblock p, .sidebarblock dt, .sidebarblock td.content, p.tableblock {
    font-size: 1em
}

.exampleblock>.content {
    background-color: #fffef7;
    border-color: #e0e0dc;
    -webkit-box-shadow: 0 1px 4px #e0e0dc;
    box-shadow: 0 1px 4px #e0e0dc
}

.print-only {
    display: none!important
}

@media print {
    @page {
        margin: 1.25cm .75cm
    }
    * {
        -webkit-box-shadow: none!important;
        box-shadow: none!important;
        text-shadow: none!important
    }
    a {
        color: inherit!important;
        text-decoration: underline!important
    }
    a.bare, a[href^="#"], a[href^="mailto:"] {
        text-decoration: none!important
    }
    a[href^=";http:"]:not(.bare):after, a[href^="https:"]:not(.bare):after {
        content: "(" attr(href) ")";
        display: inline-block;
        font-size: .875em;
        padding-left: .25em
    }
    abbr[title]:after {
        content: " (" attr(title) ")"
    }
    pre, blockquote, tr, img, object, svg {
        page-break-inside: avoid
    }
    thead {
        display: table-header-group
    }
    svg {
        max-width: 100%
    }
    p, blockquote, dt, td.content {
        font-size: 1em;
        orphans: 3;
        widows: 3
    }
    h2, h3, #toctitle, .sidebarblock>.content>.title {
        page-break-after: avoid
    }
    #toc, .sidebarblock, .exampleblock>.content {
        background: none!important
    }
    #toc {
        border-bottom: 1px solid #ddddd8!important;
        padding-bottom: 0!important
    }
    .sect1 {
        padding-bottom: 0!important
    }
    .sect1+.sect1 {
        border: 0!important
    }
    #header>h1:first-child {
        margin-top: 1.25rem
    }
    body.book #header {
        text-align: center
    }
    body.book #header>h1:first-child {
        border: 0!important;
        margin: 2.5em 0 1em 0
    }
    body.book #header .details {
        border: 0!important;
        display: block;
        padding: 0!important
    }
    body.book #header .details span:first-child {
        margin-left: 0!important
    }
    body.book #header .details br {
        display: block
    }
    body.book #header .details br+span:before {
        content: none!important
    }
    body.book #toc {
        border: 0!important;
        text-align: left!important;
        padding: 0!important;
        margin: 0!important
    }
    body.book #toc, body.book #preamble, body.book h1.sect0, body.book .sect1>h2 {
        page-break-before: always
    }
    .listingblock code[data-lang]:before {
        display: block
    }
    #footer {
        background: none!important;
        padding: 0 .9375em
    }
    #footer-text {
        color: rgba(0, 0, 0, .6)!important;
        font-size: .9em
    }
    .hide-on-print {
        display: none!important
    }
    .print-only {
        display: block!important
    }
    .hide-for-print {
        display: none!important
    }
    .show-for-print {
        display: inherit!important
    }
}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
pre.rouge table td { padding: 5px; }
pre.rouge table pre { margin: 0; }
pre.rouge, pre.rouge .w {
  color: #303030;
}
pre.rouge .err {
  color: #151515;
  background-color: #ac4142;
}
pre.rouge .c, pre.rouge .ch, pre.rouge .cd, pre.rouge .cm, pre.rouge .cpf, pre.rouge .c1, pre.rouge .cs {
  color: #505050;
}
pre.rouge .cp {
  color: #f4bf75;
}
pre.rouge .nt {
  color: #f4bf75;
}
pre.rouge .o, pre.rouge .ow {
  color: #d0d0d0;
}
pre.rouge .p, pre.rouge .pi {
  color: #d0d0d0;
}
pre.rouge .gi {
  color: #90a959;
}
pre.rouge .gd {
  color: #ac4142;
}
pre.rouge .gh {
  color: #6a9fb5;
  background-color: #151515;
  font-weight: bold;
}
pre.rouge .k, pre.rouge .kn, pre.rouge .kp, pre.rouge .kr, pre.rouge .kv {
  color: #aa759f;
}
pre.rouge .kc {
  color: #d28445;
}
pre.rouge .kt {
  color: #d28445;
}
pre.rouge .kd {
  color: #d28445;
}
pre.rouge .s, pre.rouge .sb, pre.rouge .sc, pre.rouge .dl, pre.rouge .sd, pre.rouge .s2, pre.rouge .sh, pre.rouge .sx, pre.rouge .s1 {
  color: #90a959;
}
pre.rouge .sa {
  color: #aa759f;
}
pre.rouge .sr {
  color: #75b5aa;
}
pre.rouge .si {
  color: #8f5536;
}
pre.rouge .se {
  color: #8f5536;
}
pre.rouge .nn {
  color: #f4bf75;
}
pre.rouge .nc {
  color: #f4bf75;
}
pre.rouge .no {
  color: #f4bf75;
}
pre.rouge .na {
  color: #6a9fb5;
}
pre.rouge .m, pre.rouge .mb, pre.rouge .mf, pre.rouge .mh, pre.rouge .mi, pre.rouge .il, pre.rouge .mo, pre.rouge .mx {
  color: #90a959;
}
pre.rouge .ss {
  color: #90a959;
}
</style>
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Learn Mojo Programming Language</h1>
<div class="details">
<span id="author" class="author">Indukumar Vellapillil-Hari</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_dedication">Dedication</a></li>
<li><a href="#_introduction">1. Introduction</a></li>
<li><a href="#_getting_started">2. Getting started</a>
<ul class="sectlevel2">
<li><a href="#_getting_mojo">2.1. Getting Mojo</a></li>
<li><a href="#_hello_world">2.2. Hello World</a></li>
<li><a href="#_dissecting_the_program">2.3. Dissecting the program</a></li>
<li><a href="#_compiler">2.4. Compiler</a></li>
</ul>
</li>
<li><a href="#_functions">3. Functions</a>
<ul class="sectlevel2">
<li><a href="#_def">3.1. def</a></li>
<li><a href="#_fn">3.2. fn</a></li>
<li><a href="#_benefits_of_fn_over_def">3.3. Benefits of <code>fn</code> over <code>def</code></a></li>
<li><a href="#_benefits_of_def_over_fn">3.4. Benefits of <code>def</code> over <code>fn</code></a></li>
<li><a href="#_mixing_and_matching">3.5. Mixing and matching</a></li>
<li><a href="#_default_return_types">3.6. Default return types</a></li>
<li><a href="#_main_function">3.7. <code>main</code> function</a></li>
<li><a href="#_different_styles_of_writing_functions">3.8. Different styles of writing functions</a></li>
<li><a href="#_arguments_passed_to_functions">3.9. Arguments passed to functions</a></li>
<li><a href="#_nested_functions">3.10. Nested functions</a></li>
<li><a href="#_keyword_arguments">3.11. Keyword arguments</a></li>
<li><a href="#_default_value">3.12. Default value</a></li>
</ul>
</li>
<li><a href="#_constants_and_variables">4. Constants and variables</a>
<ul class="sectlevel2">
<li><a href="#_constants">4.1. Constants</a></li>
<li><a href="#_variables">4.2. Variables</a></li>
<li><a href="#_alias">4.3. Alias</a></li>
<li><a href="#_undeclared_variables">4.4. Undeclared variables</a></li>
<li><a href="#_variable_scoping">4.5. Variable scoping</a></li>
<li><a href="#_non_standard_identifiers">4.6. Non-standard identifiers</a></li>
</ul>
</li>
<li><a href="#_types">5. Types</a>
<ul class="sectlevel2">
<li><a href="#_bool">5.1. Bool</a></li>
<li><a href="#_int">5.2. Int</a></li>
<li><a href="#_intliteral">5.3. IntLiteral</a></li>
<li><a href="#_string">5.4. String</a></li>
<li><a href="#_stringliteral">5.5. StringLiteral</a></li>
<li><a href="#_floatliteral">5.6. FloatLiteral</a></li>
<li><a href="#_float16">5.7. Float16</a></li>
<li><a href="#_float32">5.8. Float32</a></li>
<li><a href="#_float64">5.9. Float64</a></li>
<li><a href="#_int8">5.10. Int8</a></li>
<li><a href="#_uint8">5.11. UInt8</a></li>
<li><a href="#_int16">5.12. Int16</a></li>
<li><a href="#_uint16">5.13. UInt16</a></li>
<li><a href="#_int32">5.14. Int32</a></li>
<li><a href="#_uint32">5.15. UInt32</a></li>
<li><a href="#_int64">5.16. Int64</a></li>
<li><a href="#_uint64">5.17. UInt64</a></li>
<li><a href="#_bfloat16">5.18. BFloat16</a></li>
<li><a href="#_simd">5.19. SIMD</a></li>
<li><a href="#_dtype">5.20. DType</a></li>
<li><a href="#_type_safety">5.21. Type safety</a></li>
<li><a href="#_object">5.22. object</a></li>
<li><a href="#_tuple">5.23. Tuple</a></li>
<li><a href="#_listliteral">5.24. ListLiteral</a></li>
<li><a href="#_dictliteral">5.25. DictLiteral</a></li>
</ul>
</li>
<li><a href="#_documenting_your_code">6. Documenting your code</a>
<ul class="sectlevel2">
<li><a href="#_comments">6.1. Comments</a></li>
<li><a href="#_docstrings">6.2. Docstrings</a></li>
</ul>
</li>
<li><a href="#_struct">7. Struct</a>
<ul class="sectlevel2">
<li><a href="#_instance_methods">7.1. Instance methods</a></li>
<li><a href="#_static_methods">7.2. Static methods</a></li>
<li><a href="#_implicit_conversion">7.3. Implicit conversion</a></li>
</ul>
</li>
<li><a href="#_trait">8. Trait</a></li>
<li><a href="#_control_flow">9. Control flow</a>
<ul class="sectlevel2">
<li><a href="#_if_else">9.1. <code>if</code>-<code>else</code></a></li>
<li><a href="#_elif">9.2. <code>elif</code></a></li>
<li><a href="#_nesting_of_if">9.3. Nesting of <code>if</code></a></li>
<li><a href="#_if_as_expression">9.4. <code>if</code> as expression</a></li>
<li><a href="#_case">9.5. <code>case</code></a></li>
<li><a href="#_while">9.6. <code>while</code></a></li>
<li><a href="#_for">9.7. <code>for</code></a></li>
<li><a href="#_skipping_and_exiting_early_from_loops">9.8. Skipping and exiting early from loops</a></li>
</ul>
</li>
<li><a href="#_error_handling">10. Error handling</a>
<ul class="sectlevel2">
<li><a href="#_error_propagation">10.1. Error propagation</a></li>
<li><a href="#_finally">10.2. Finally</a></li>
<li><a href="#_else">10.3. Else</a></li>
</ul>
</li>
<li><a href="#_operators_and_special_methods">11. Operators and special methods</a>
<ul class="sectlevel2">
<li><a href="#_arithmetic_operators">11.1. Arithmetic operators</a></li>
<li><a href="#_bitwise_operators">11.2. Bitwise operators</a></li>
<li><a href="#_relational_operators">11.3. Relational operators</a></li>
<li><a href="#_index_operators">11.4. Index operators</a></li>
<li><a href="#_context_management_methods">11.5. Context management methods</a></li>
<li><a href="#_other_special_methods">11.6. Other special methods</a></li>
</ul>
</li>
<li><a href="#_lifecycle_and_ownership">12. Lifecycle and ownership</a>
<ul class="sectlevel2">
<li><a href="#_pass_by_value_and_pass_by_reference">12.1. Pass by value and pass by reference</a></li>
<li><a href="#_borrowed">12.2. borrowed</a></li>
<li><a href="#_owned">12.3. owned</a></li>
<li><a href="#_inout">12.4. inout</a></li>
<li><a href="#_init">12.5. <code>__init__</code></a></li>
<li><a href="#_del">12.6. <code>__del__</code></a></li>
<li><a href="#_copyinit">12.7. <code>__copyinit__</code></a></li>
<li><a href="#_moveinit">12.8. <code>__moveinit__</code></a></li>
</ul>
</li>
<li><a href="#_parameters_and_compile_time_programming">13. Parameters and compile-time programming</a>
<ul class="sectlevel2">
<li><a href="#_compile_time_execution_of_code">13.1. Compile-time execution of code</a></li>
<li><a href="#_conditional_execution_at_compile_time">13.2. Conditional execution at compile-time</a></li>
<li><a href="#_parameters_in_functions">13.3. Parameters in functions</a></li>
<li><a href="#_keyword_parameters">13.4. Keyword parameters</a></li>
<li><a href="#_variadic_parameters">13.5. Variadic parameters</a></li>
<li><a href="#_default_values_in_parameters">13.6. Default values in parameters</a></li>
<li><a href="#_parameters_in_structs_traits">13.7. Parameters in structs, traits</a></li>
</ul>
</li>
<li><a href="#_advanced_usage_of_functions">14. Advanced usage of functions</a>
<ul class="sectlevel2">
<li><a href="#_higher_order_functions">14.1. Higher-order functions</a></li>
<li><a href="#_closure">14.2. Closure</a></li>
<li><a href="#_variadic_function">14.3. Variadic function</a></li>
<li><a href="#_overloading">14.4. Overloading</a></li>
</ul>
</li>
<li><a href="#_about_the_author">About the author</a></li>
<li><a href="#_revision_history">Revision History</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_dedication">Dedication</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To my family, for their constant and unfailing love and support.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_introduction">1. Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Mojo programming language was announced by the company Modular on May 2023. It was positioned as a language to build AI programs. However, the language they built was a much more powerful general purpose language. Mojo was designed from the start to be a super set of Python which was already entrenched deep in the domain of machine learning and AI. Python has over the many years built up a reputation of being one of the most easiest language for beginners to learn programming. Mojo having built up on the shoulders of this giant, offers an easy to use language with capabilities that challenge even the most powerful system languages such as C, C++ and Rust.</p>
</div>
<div class="paragraph">
<p>Mojo is built on top of MLIR, a reusable and extensible compiler infrastructure. This allowed team to benefit from multi-years of efforts already spent on MLIR. Mojo exposes ability to embed MLIR within its own programs, enabling much deeper optimizations. The design choices such as these allow Mojo to be used to build operating systems and device drivers where close interaction with hardware and high performance is necessary. The high level Python syntax, static and dynamic typing support, and the extensive Mojo standard library allows also developers to build enterprise software as easy as building a Python application. In effect, Mojo is able to support a very wide range of programming domains, ranging from operating systems up to enterprise Web applications.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_getting_started">2. Getting started</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_getting_mojo">2.1. Getting Mojo</h3>

</div>
<div class="sect2">
<h3 id="_hello_world">2.2. Hello World</h3>
<div class="paragraph">
<p>It is a time honored tradition to start learning a programming language with a program printing "Hello, World!". Let&#8217;s start with that.</p>
</div>
<div class="paragraph">
<p>Please open a text editor of your choice and type the following and save the file as <code>hello_world.mojo</code>. The name of the file does not matter as long as you pass the same file to the compiler.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">print("Hello, World!")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now open a command line program and enter the following in its terminal.</p>
</div>
<div class="paragraph">
<p><code>mojo hello_world.mojo</code></p>
</div>
<div class="paragraph">
<p>You should see the following in the terminal.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>Hello, World!</code></pre>
</div>
</div>
<div class="paragraph">
<p>Congrats! You have executed your first Mojo program!</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Alternate file extension</div>
<div class="paragraph">
<p>Mojo also supports file extension other than ".mojo". Instead of saving the file as <code>hello_world.mojo</code>, you can save it as <code>hello_world.🔥</code> and run <code>mojo hello_world.🔥</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_dissecting_the_program">2.3. Dissecting the program</h3>
<div class="paragraph">
<p>Unlike many other system languages, Mojo has very minimal ceremony to define a simple program like Hello World.
The following line (known as a statement) calls a function named <code>print</code> which is provided by Mojo. The text <code>Hello, World!</code> is placed inside double quotes. Any text placed inside double quotes (or single quotes for that matter) is considered by Mojo as a String Literal. Literals are constant values that do not change during the execution of the program and are provided directly to the program source code. In this case, we pass the value "Hello, World!" to the function <code>print</code>.</p>
</div>
<div class="paragraph">
<p>The <code>print</code> function knows how to take that passed value and to bring it into the screen.</p>
</div>
</div>
<div class="sect2">
<h3 id="_compiler">2.4. Compiler</h3>
<div class="paragraph">
<p>The command <code>mojo hello_world.mojo</code> you executed in the terminal took the Mojo source code and compiled it into a form that can be executed in the computer. The <code>mojo</code> command then directly executes the compiled form.</p>
</div>
<div class="paragraph">
<p>If you do not want to execute immediately the program, and just want to create an executable file, you can use the command <code>mojo build hello_world.mojo</code>. It then creates an executable file in the same directory as the source file.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_functions">3. Functions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the previous chapter you saw how a function <code>print</code> is being called in a program. In order to call a function, the function must be defined somewhere. In Mojo, there are two ways to define a function. The first way would be very familiar to Python developers. The second one is more closer to another language, Rust.</p>
</div>
<div class="sect2">
<h3 id="_def">3.1. def</h3>
<div class="paragraph">
<p>One way to define a function is by using the keyword <code>def</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">def my_function(text):
    print(text)

my_function("Hello World!")</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>def</code> function definitions have the least ceremony. For beginners it is the easiest way to define functions and closely resembles how Python functions are defined. In the above code, <code>def my_function(text):</code> defined a function named <code>my_function</code> and declared that it takes an argument <code>text</code>. The following statement <code>my_function("Hello World!")</code> calls that function <code>my_function</code> and passes "Hello World!" as the argument where <code>text</code> was declared.</p>
</div>
<div class="paragraph">
<p>You may have noticed that after <code>def my_function(text):</code>, there is a new line and 4 spaces before the statement <code>print(text)</code>. This is because Mojo, like Python, uses whitespace indentation to demarcate the function&#8217;s body. Many mainstream programming languages use braces "{}" for function body. However, Mojo uses indented whitespace and is particular about the whitespace being aligned. You will find this syntax not only for function bodies, but also for other statements that expect a block. We will come to those cases in later chapters. Please notice that the statement <code>my_function("Hello World!")</code> appears differently aligned than <code>print(text)</code>. This is because <code>my_function("Hello World!")</code> is not part of the `my_function&#8217;s body itself.</p>
</div>
<div class="paragraph">
<p>The following illustration shows the simplified structure of a Mojo function.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/Users/indu/Documents/Projects/Books/books/Learn_Mojo_Programming_Language/chapters/resources/graphics/Function_Structure_Def.jpeg" alt="Function Structure Def">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_fn">3.2. fn</h3>
<div class="paragraph">
<p>The other way to define is function is by using the keyword <code>fn</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">fn my_function(text: StringLiteral):
    print(text)

my_function("Hello World!")</code></pre>
</div>
</div>
<div class="paragraph">
<p>While the <code>def</code> based function definitions demands only the most essential elements, the <code>fn</code> based function definitions are more strict in nature. The reason for this is simple. The <code>fn</code> functions are intended to be high performance and for it to be high performant, it needs to provide the Mojo compiler with much more details. The details help the Mojo compiler to create an optimized version of the executable file.</p>
</div>
<div class="paragraph">
<p>What are those details that help Mojo compiler? The main element that helps Mojo compiler is something called the "type" of a variable. In the above example, you see the definition <code>text: StringLiteral</code>. In comparison to the <code>def</code> version of the function, we have a new declaration <code>: StringLiteral</code>. This is called a type annotation. This declaration says that the function argument <code>text</code> will contain <strong>only</strong> String literals. More importantly, it will <strong>never</strong> contain any other content than String literals. This gives the Mojo compiler a very important hint. Without such a hint, the Mojo compiler has to accommodate many different scenarios. For example, if we do not declare that the <code>text</code> is of type StringLiteral, it will have to assume that the <code>text</code> may contain numbers or other types of objects. Then it has to generate a very generic executable code that is able to handle many other types of values. However, when we tell Mojo compiler that the <code>text</code> will take only StringLiterals, it can generate a very specific and highly optimized code that handles only StringLiterals.</p>
</div>
<div class="paragraph">
<p>The body of the <code>fn</code> functions are also demarcated by whitespace similar to <code>def</code> functions.</p>
</div>
<div class="paragraph">
<p>The following illustration shows the simplified structure of a <code>fn</code> function.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/Users/indu/Documents/Projects/Books/books/Learn_Mojo_Programming_Language/chapters/resources/graphics/Function_Structure_Fn.jpeg" alt="Function Structure Fn">
</div>
</div>
<div class="paragraph">
<p>You may have noticed one additional concept that we did not yet touch upon. The return type. Both <code>fn</code> and <code>def</code> functions support returning values from the function. So far we have not used it. However, in many cases we want to call functions to perform calculations and after the calculations are completed, we expect a result as output from the function. The following example shows such a use case.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">def add(a, b):
    return a + b

print(add(1, 2))</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you run the above program, you get the output as <code>3</code>.</p>
</div>
<div class="paragraph">
<p>The function <code>add</code> took two arguments and performed an addition. Then it returned that result with keyword <code>return</code>, which was then shown on the terminal using the <code>print</code> function. The statement <code>print(add(1, 2))</code> actually made two function calls. The inner function call <code>add</code> got executed first and then the outer function call <code>print</code>. This is called the nesting of function calls. The result from the inner function call was passed to the outer function call.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">mojo addition_return_def.mojo
3</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, the same using <code>fn</code> function definition.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">fn add(a: Int, b: Int) -&gt; Int:
    return a + b

print(add(1, 2))</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you run the above program, you get the output as <code>3</code>. Here you may have noticed that the type of the values are being explicitly declared. The arguments passed to the function are both <code>Int</code> types and the return value of the function is also of type <code>Int</code>. The <code>Int</code> type represents all integer values, including both positive and negative values. The actual value is passed during the function call statement (call site).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">mojo addition_return_fn.mojo
3</code></pre>
</div>
</div>
<div class="paragraph">
<p>In case of <code>fn</code> function, we indicated in the function definition that the function will return a value of type <code>Int</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_benefits_of_fn_over_def">3.3. Benefits of <code>fn</code> over <code>def</code></h3>
<div class="paragraph">
<p>As mentioned earlier, one of the benefits of using <code>fn</code> is to provide information to the compiler that would be used by the compiler to produce a highly performance code. The second benefit is to enforce program correctness.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look into the following program.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">def add(a, b):
    return a + b

print(add(1, 1.5))</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you execute the above program, you would see the result as <code>2.5</code>. Behind the scenes, the expression <code>add(1, 1.5)</code> added two different types. The first argument was of type <code>Int</code> and the second argument was of type <code>Float</code>. The addition&#8217;s result is of type <code>Float</code>.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">FloatLiteral vs Float</div>
<div class="paragraph">
<p>I am glossing over when I say that <code>1.5</code> is a <code>Float</code>. Since it is provided in the source code directly, its actual type is <code>FloatLiteral</code>.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>The above program worked fine for us. But what if we wanted to restrict addition to only integers? How can we prevent someone from passing Float values to <code>add</code> function?</p>
</div>
<div class="paragraph">
<p>The answer is by using <code>fn</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">fn add(a: Int, b: Int) -&gt; Int:
    return a + b

print(add(1, 2.5))</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you now execute the above program, you would get a compiler error (you may have slightly different error message depending upon the version of the Mojo compiler used).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">addition_return_fn_2.mojo:4:21: error: invalid call to 'add': argument #1 cannot be converted from 'FloatLiteral' to 'Int'</code></pre>
</div>
</div>
<div class="paragraph">
<p>The Mojo compiler complains because we have strictly restricted the argument type of <code>b</code> to <code>Int</code> and Mojo compiler cannot convert the passed value to <code>Int</code>. You have a guarantee from the Mojo compiler that only those values that can be converted safely into <code>Int</code> will be allowed to be passed. We say that the Mojo compiler ensures type safety when we use <code>fn</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_benefits_of_def_over_fn">3.4. Benefits of <code>def</code> over <code>fn</code></h3>
<div class="paragraph">
<p>If <code>fn</code> is safer than <code>def</code>, then why should we use <code>def</code> at all? <code>def</code> has its uses. For example, if you want to prototype something and you are not sure what types to use, you can leave that decision for a later time and focus on the algorithm itself. Sometimes you really need the flexibility and dynamism of Python. In this case, <code>def</code> is the most appropriate way to go.</p>
</div>
<div class="paragraph">
<p>Mojo treats both <code>def</code> and <code>fn</code> styles as first class and both of them are useful in different contexts.</p>
</div>
</div>
<div class="sect2">
<h3 id="_mixing_and_matching">3.5. Mixing and matching</h3>
<div class="paragraph">
<p>Although <code>def</code> does not <em>require</em> you to provide types, it does not <em>prevent</em> you from declaring types. For example, the following  will have the same effect as the above mentioned <code>fn</code> version.</p>
</div>
<div class="paragraph">
<p>You may wonder what is the type of <code>a</code> in the <code>def</code> function. Its type is <code>object</code>. All values that do not have an explicit type is by default assigned as <code>object</code> type in Mojo. We will come back to it in detail later on in subsequent chapters.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">def add(a, b: Int):
    return a + b

print(add(1, 1.5))</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">error: invalid call to 'add': argument #1 cannot be converted from 'FloatLiteral' to 'Int'</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_default_return_types">3.6. Default return types</h3>
<div class="paragraph">
<p>In the <code>def</code> function, when you omit the return type annotations then Mojo assumes that the return type is <code>object</code>. However, in <code>fn</code> functions, when you omit the return type, then Mojo defaults to <code>None</code>, which indicates that there is no value being returned.</p>
</div>
</div>
<div class="sect2">
<h3 id="_main_function">3.7. <code>main</code> function</h3>
<div class="paragraph">
<p>There is a special function called <code>main</code> in Mojo, which is the function that is used by the compiler to determine the main entrance of a program. When you call a program executable created by Mojo, the very first function that is executed is the <code>main</code> function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">def main():
    print("Hello World!")</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you execute the above program, the main function will be called automatically and the text <code>Hello World!</code> will be printed.</p>
</div>
</div>
<div class="sect2">
<h3 id="_different_styles_of_writing_functions">3.8. Different styles of writing functions</h3>
<div class="paragraph">
<p>A function can be defined in different styles.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">def func1(r): ...

def func2(): pass

def func3(): print("Hello World!"); print("Good bye!")

def func4(): 
    pass</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that all the above style is also valid for <code>fn</code> functions. <code>fn</code> functions are the same as <code>def</code> functions, except for the difference that it demands type annotations.
You can define the function body in the same line as the function definition only if the whole body is just a single line.</p>
</div>
<div class="sect3">
<h4 id="_semicolon">3.8.1. Semicolon</h4>
<div class="paragraph">
<p>In the source code shown above, you may have noticed a semicolon in the body of function <code>func3</code>. Semicolon can be used to separate statements, which allow the statements to be written in a single line. Mojo follows the philosophy of Python, so use semicolon sparingly and only when it improves reading and understanding of code.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ellipses_in_functions">3.8.2. Ellipses in functions</h4>
<div class="paragraph">
<p>In Mojo you would often see <code>&#8230;&#8203;</code> defined in the function body. Ellipsis is just a built-in constant in Mojo, and is a placeholder. Within a function, it just means that the body is not yet implemented and the Mojo compiler will not complain about the missing body. Ellipses have other uses and we will cover them in subsequent chapters.</p>
</div>
</div>
<div class="sect3">
<h4 id="_pass_in_functions">3.8.3. <code>pass</code> in functions</h4>
<div class="paragraph">
<p>The <code>pass</code> keyword has a similar role as <code>&#8230;&#8203;</code> in functions. It particularly tells the compiler that the implementation has been omitted.</p>
</div>
<div class="paragraph">
<p>One good rule of thumb is to use <code>pass</code> where you know that there is no need for an implementation and use <code>&#8230;&#8203;</code> when you are expecting some implementation in the future (or in inherited entities - we will come to that later).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_arguments_passed_to_functions">3.9. Arguments passed to functions</h3>
<div class="paragraph">
<p>Arguments passed to a function cannot be modified within the function. Such arguments are said to be immutable as the function body cannot modify their value. This kind of restriction is helpful in large programs as the code that calls the function does not get surprised that the value it passed to a function has suddenly changed unexpectedly.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">fn add(a: Int, b: Int) -&gt; Int:
    a = a + 1
    return a + b

fn main(): print(add(1, 2))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Executing the above listed code results in compilation error.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>error: expression must be mutable in assignment
    a = a + 1
    ^
mojo: error: failed to parse the provided Mojo</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_nested_functions">3.10. Nested functions</h3>
<div class="paragraph">
<p>Mojo supports nesting of function within other functions. This applies to both <code>fn</code> and <code>def</code> style functions.</p>
</div>
<div class="paragraph">
<p>Nesting of functions limit the scope of the nested function to just the outer function. For example in the following code listing, it is not possible to call <code>nested</code> within <code>main</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">fn outer():
    fn nested():
        print("I am nested")
    nested()

fn main():
    outer()</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_keyword_arguments">3.11. Keyword arguments</h3>
<div class="paragraph">
<p>Sometimes when functions take lots of arguments, it is much more clear if the name of the argument is specified when calling the function. Mojo supports keyword arguments, which is basically the ability to specify the argument name when we assign a value to that argument during a function call.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">fn my_function(first: Int, second: Int) -&gt; Int:
    return first + second

fn main():
    print(my_function(first = 1, second = 2))
    print(my_function(second = 2, first = 3))
    print(my_function(4, second = 5))</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the previous listing, we can see there are three different ways to call the function with keyword arguments. The first one specifies the name of the both arguments when passing the value. The second call demonstrates that when using the keyword arguments, the order of the arguments does not matter, as Mojo knows with the name itself which argument gets which value. In the third call, we see that we can mix and match positional argument with the keyword argument; however, here the order is important as the positional values must appear in the order in which they were declared in the function definition. Keyword arguments follow positional arguments.</p>
</div>
<div class="paragraph">
<p>What if you as an API designer want some arguments to be always specified positionally? In this case, you can enforce positional arguments by using a special argument, <code>/</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">fn my_function2(first: Int, second: Int, /) -&gt; Int:
    return first + second

fn main():
    print(my_function2(first=1, second=2)) # compiler error</code></pre>
</div>
</div>
<div class="paragraph">
<p>Executing the above listed code results in compilation error.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>error: invalid call to 'my_function2': positional-only arguments passed as keyword operands: 'first', 'second'</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also mix and match position-only arguments with keyword arguments. The <code>/</code> can be the last argument, in which case all the function arguments would be position-only. It cannot be the first argument though.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">fn my_function(first: Int, second: Int, /, third: Int) -&gt; Int:
    return first + second + third

fn main():
    print(my_function(1, 2, third=3))
    print(my_function(1, 2, 3))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here the first two arguments are strictly position-only, while the third can be passed as keyword or positional as desired.</p>
</div>
<div class="paragraph">
<p>What if you wanted some arguments to be always keyword only? In this case, you can enforce keyword arguments by using the special argument, <code>*</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">fn my_function(first: Int, *, second: Int, third: Int) -&gt; Int:
    return first + second + third

fn main():
    print(my_function(1, second=2, third=3))
    #print(my_function(1, 2, 3)) # Uncommenting would result in compiler error.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similar to <code>/</code>, you can also mix and match keyword-only arguments with positional arguments. The <code>*</code> can be the first argument, in which case all the function arguments would be keyword-only. It cannot be the last argument though.</p>
</div>
<div class="paragraph">
<p>Keyword arguments make APIs ergonomic, as the programmer does not have to remember in which position what value need to be passed. It improves code readability and maintainability. It also reduces accidental mistakes when programmer wrongly assumes the order of the arguments.</p>
</div>
<div class="paragraph">
<p>Keyword arguments are applicable for both <code>def</code> and <code>fn</code> forms.</p>
</div>
</div>
<div class="sect2">
<h3 id="_default_value">3.12. Default value</h3>
<div class="paragraph">
<p>Mojo allows assigning default values to function arguments, which means when the caller does not pass a value to the argument, the function will take the given default value. That function argument therefore becomes optional for the caller. The default value must be of the same data type as the declared data type of the argument.</p>
</div>
<div class="paragraph">
<p>This feature is quite useful when defining ergonomic APIs, providing sensible default values for the caller, making the function easier to use.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">fn deft_function(first: Int, second: Int = 10) -&gt; Int:
    return first + second

fn main():
    print(deft_function(1)) # 'second' defaults to '10'
    print(deft_function(1, 2))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Default values are applicable for both <code>def</code> and <code>fn</code> forms.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_constants_and_variables">4. Constants and variables</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Sometimes you need to store a value before it can be used in a function. Mojo offers two ways to store a value for later use. One is the concept called a constant and the other one is variable.</p>
</div>
<div class="sect2">
<h3 id="_constants">4.1. Constants</h3>
<div class="paragraph">
<p>Suppose you have two functions, one that calculates circumference of a circle  and the other that calculates the area of a circle.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">def circumference(r):
    return 2 * 3.14 * r

def area(r):
    return 3.14 * r * r

def main():
    print(circumference(25))
    print(area(25))</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example, the PI has been limited to 2 decimal places. What if we want to increase our precision and increase the PI to 4 decimal places? Then we need to change both the functions <code>circumference</code> and <code>area</code>.</p>
</div>
<div class="paragraph">
<p>An alternative is to define PI as a constant using the keyword <code>alias</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">alias PI = 3.14

def circumference(r):
    return 2 * PI * r

def area(r):
    return PI * r * r

def main():
    print(circumference(25))
    print(area(25))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The result of both the programs are the same. However, we have now defined PI in one single place and we can change its value in just one place and the updated value is reflected wherever the constant <code>PI</code> is referred.</p>
</div>
<div class="paragraph">
<p>The main benefit of a constant is that the compiler prevents any attempt to change the initially assigned value during the program execution.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">fn main():
    alias counter: Int = 1
    print(counter)
    counter = counter + 3
    print(counter)</code></pre>
</div>
</div>
<div class="paragraph">
<p>For example, executing the above program results in:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>error: expression must be mutable in assignment
    counter = counter + 3
    ^~~~~~~
mojo: error: failed to parse the provided Mojo</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_variables">4.2. Variables</h3>
<div class="paragraph">
<p>In contrast to the constants, values stored within variables are expected to change during the program execution. An example could be a counter which gets updated each time a user clicks a button.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">fn main():
    var counter: Int = 1
    print(counter)
    counter = counter + 3
    print(counter)</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you execute the above program, you would see the result:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>1
4</code></pre>
</div>
</div>
<div class="paragraph">
<p>The statement <code>var counter: Int = 1</code> assigned the value <code>1</code> to the variable called counter. The keyword <code>var</code> declares that <code>counter</code> is a variable. The statement <code>counter = counter + 3</code> adds value <code>3</code> to counter, resulting in value <code>4</code>.</p>
</div>
<div class="paragraph">
<p>You do not always need to initialize a variable with value. You can also just write <code>var counter: Int</code> and initialize its value later when needed. However, ensure that you initialize a variable before first use of that variable, otherwise you will encounter a compilation error.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">fn main():
    var counter: Int
    print(counter)
    counter = counter + 3
    print(counter)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Results in:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>error: use of uninitialized value 'counter'
    print(counter)
          ^</code></pre>
</div>
</div>
<div class="paragraph">
<p>The solution to above is to assign a value to <code>counter</code> before printing it.</p>
</div>
</div>
<div class="sect2">
<h3 id="_alias">4.3. Alias</h3>
<div class="paragraph">
<p>The <code>alias</code> feature provided by Mojo is much more powerful than just declaring constants. In fact, it enforces compile time execution of statements that come on the right hand side of the <code>=</code> symbol.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">alias MY_VALUE = add(2, 3)

fn add(a: Int, b: Int) -&gt; Int:
    return a + b

fn main():
    print(MY_VALUE)</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the code sample shown above, you see that Mojo allows compile time execution of a normal function. Executing the program results in the printing of the value <code>5</code> on screen.</p>
</div>
<div class="paragraph">
<p>There are some restrictions on what type of functions can be called during compile time. For example, <code>def</code> style functions cannot be called during compile time. Another restriction is that function that are called during compile must not have any side effects. That is, the functions must use only the arguments passed to it and must not change any variables or state <em>outside</em> of the function body. These kind of functions are called <em>pure</em> functions.</p>
</div>
<div class="paragraph">
<p>You can also assign types to <code>alias</code> as shown in the next example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">alias MyInt = Int

fn add(a: MyInt, b: MyInt) -&gt; MyInt:
    return a + b

fn main():
    print(add(1, 2))</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the previous example, the <code>MyInt</code> is exactly the same as <code>Int</code>, just with a different name.</p>
</div>
</div>
<div class="sect2">
<h3 id="_undeclared_variables">4.4. Undeclared variables</h3>
<div class="paragraph">
<p>Mojo allows variables to be defined without the <code>var</code> keyword. However, that works only within <code>def</code> functions. <code>fn</code> functions are strict regarding declaration of variables and require <code>var</code> keyword.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">def main():
    counter = 1
    print(counter)
    counter = counter + 3
    print(counter)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_variable_scoping">4.5. Variable scoping</h3>
<div class="paragraph">
<p>Scoping of a variable means which part of the program sees what value of the variable, and whether or not the variable is even valid at that location. In Mojo functions, a variable can have either a lexical scope or the function scope.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">def main():
    x = 1
    y = 1
    if True:
        x = 4
        print("inner x:", x)
        var y = 4
        print("inner y:", y)
    print("outer x:", x)
    print("outer y:", y)</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you execute the code shown above (please ignore the warnings for the moment), you see:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>inner x: 4
inner y: 4
outer x: 4
outer y: 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you look carefully, the <code>y</code> declared inside the <code>if</code> block had two different values when printed. The inner block had value <code>4</code> and the outer block preserved its original value of <code>1</code>. The <code>x</code> variable on the other hand got overwritten by newer value <code>4</code>. What happened is that the inner scope from the <code>if</code> block declared a <em>new</em> variable using <code>var</code> keyword. This <em>shadowed</em> the outer variable declaration, resulting in inner scoped variable being different from the outer one, even though the name of the variable was the same. In case of <code>x</code>, no such re-declaration happened, so the scope of <code>x</code> was for the whole function. The <code>var</code> declaration caused <code>y</code> to be lexically scoped within the <code>if</code> block.</p>
</div>
</div>
<div class="sect2">
<h3 id="_non_standard_identifiers">4.6. Non-standard identifiers</h3>
<div class="paragraph">
<p>As mentioned in the beginning of the book, Mojo is a superset of Python. However, there are Mojo keywords that are valid Python identifiers. Since Mojo aims to be compatible with Python, Mojo allows for such variables to be defined within backticks ``. In fact, any kind of text could be used as a variable or function name in Mojo if it is within backticks.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">fn main():
    var `var` : Int = 1
    var `with space`: Int = 2

    fn `with#symbol`() -&gt; Int:
        return 3

    print(`var`)
    print(`with space`)
    print(`with#symbol`())</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_types">5. Types</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Mojo provides quite a number of data types out of the box for our use. Some of those types are described below.</p>
</div>
<div class="sect2">
<h3 id="_bool">5.1. Bool</h3>
<div class="paragraph">
<p>The simplest of all types, a <code>Bool</code> represents values <code>True</code> or  <code>False</code>. Bool value stores exactly one bit, either <code>1</code> representing the value <code>True</code> or <code>0</code> representing the value <code>False</code>. <code>True</code> and <code>False</code> are builtin constants in Mojo, and are treated as keywords.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var bool_value: Bool = True</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_int">5.2. Int</h3>
<div class="paragraph">
<p><code>Int</code> is one of the most used data types in programming. It represents a mathematical integer, however, there are limitations on how big a value it can store. The <code>Int</code> type in Mojo is a builtin type and its size depends on the CPU architecture your program is running on. For a 64 bit architecture, the <code>Int</code> type in Mojo has size <code>64</code> bits; whereas for a 32 bit architecture, it would be 32 bit. How big a number can fit in integer types depends on whether that integer is a "signed" or "unsigned". A signed integer means that contains both negative and positive values. An unsigned integer does not allow any negative values. <code>Int</code> is a <em>signed</em> integer and therefore in a 64 bit CPU architecture, it allows values of range from -9,223,372,036,854,775,808 until 9,223,372,036,854,775,807, both inclusive. An unsigned 64 bit integer on the other hand would have the range 0 through 18,446,744,073,709,551,615.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var int_value: Int = 42</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_intliteral">5.3. IntLiteral</h3>
<div class="paragraph">
<p><code>IntLiteral</code> is the type when you provide an integer value directly in source code. It has infinite precision, but cannot currently be represented at runtime when the value is higher than the one supported by <code>Int</code>. Mojo allows underscore character "_" to as a separator for int literals to make it easy to read large numbers.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var int_lit: IntLiteral = 10_000</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the code below, you can see that a very large value is being operated upon using a floor division (we will cover floor division later when we cover operators). This is one of the benefits of using <code>IntLiterals</code> as the compile time calculations can be done on a very large precision. When you execute the code, it will print <code>10000</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    print(9999999999999999999999999999999999999999999//999999999999999999999999999999999999999) </code></pre>
</div>
</div>
<div class="paragraph">
<p><code>IntLiterals</code> can be assigned to <code>Int</code> types. Vice versa is not possible, as the value for <code>IntLiterals</code> come from the Mojo source code. Value for the <code>Int</code> may come from other sources such as files, network or source code. This holds true for all other literal types in Mojo.</p>
</div>
</div>
<div class="sect2">
<h3 id="_string">5.4. String</h3>
<div class="paragraph">
<p><code>String</code> is also one of the most used data types in programming. It is a sequence of Unicode characters representing a given text. Unicode is a text encoding standard maintained by the Unicode Consortium and consists of more than hundred thousand codes representing characters in almost all of the world&#8217;s writing systems. Since <code>String</code> abstracts over a sequence of Unicode characters, when you determine the length of a <code>String</code>, it will return the count of characters (grapheme clusters to be precise).</p>
</div>
<div class="paragraph">
<p>However, to store or transport such a String we need to represent that String as a sequence of bytes. A popular character representation format is UTF-8, which uses one or more bytes <em>per character</em> depending on the Unicode code point (an integer value designated to represent the character).</p>
</div>
<div class="paragraph">
<p>When receiving or sending strings over files or network, always ensure that you know what encoding is being used. Quite often subtle defects occur because the programmer expected a different encoding than the one they received.</p>
</div>
<div class="paragraph">
<p>Strings in Mojo are immutable. Any modification of the String actually returns a new String.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var strg: String = "Hello World!"</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_stringliteral">5.5. StringLiteral</h3>
<div class="paragraph">
<p>When you directly provide strings in source code within double quotes or single quotes the value gets assigned the type <code>StringLiteral</code>.</p>
</div>
<div class="paragraph">
<p>Mojo allows embedding of one type of quote within a string of the other type of quote. For example, you can embed '' within "", and vice versa. However, make sure to use the same type of quotes for beginning and end of the string.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var strg_lit: StringLiteral = "Hello World!"
    var strg_lit2: StringLiteral = 'Hello World!'
    var strg_lit3: StringLiteral = 'Hello "World"!'
    var strg_lit4: StringLiteral = "Hello 'World'!"</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can define multi line strings using three double quotes like """ or three single quotes like '''. Multi line strings will preserve the new line characters and white spaces.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var strg_lit_multi: StringLiteral = """
    Hello World!
    """
    var strg_lit_multi2: StringLiteral = '''
    Hello World!
    '''
    var strg_lit_multi3: StringLiteral = '''
    Hello """World"""!
    '''
    var strg_lit_multi4: StringLiteral = """
    Hello '''World'''!
    """</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>StringLiterals</code> can be assigned to <code>String</code>; this is why when you declare a <code>String</code> variable, you are able to pass a string literal in source code to it.</p>
</div>
</div>
<div class="sect2">
<h3 id="_floatliteral">5.6. FloatLiteral</h3>
<div class="paragraph">
<p><code>FloatLiteral</code> is the type that Mojo compiler assigns to a value when you provide a decimal separated numeric value in the source code. The <code>FloatLiteral</code> is "double precision", which is represented with 64 bits. The mantissa part of the value is represented by 52 bits and the exponent part of the value is represented by 11 bits. The last remaining bit is used for sign.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var float_lit: FloatLiteral = 2.005</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_float16">5.7. Float16</h3>
<div class="paragraph">
<p><code>Float16</code> is a 16 bit floating point type, also know as "half precision". On some machines lower precision types can be much faster than higher precision types and so are quite useful if high precision is not important in your domain.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var float_16: Float16 = 1.011</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_float32">5.8. Float32</h3>
<div class="paragraph">
<p><code>Float32</code> is a 32 bit floating point type, also known as "single precision". This type has 23 bit mantissa, 8 bit exponent and the last bit used for sign.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var float_32: Float32 = 3.25</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_float64">5.9. Float64</h3>
<div class="paragraph">
<p><code>Float64</code> is a 64 bit floating point type, also known as "double precision". The 64 bits are distributed as 52 bits for mantissa, 11 bits for exponent and the last bit for sign. This is the same precision that <code>FloatLiteral</code> also has.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var float_64: Float64 = 5.6</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_int8">5.10. Int8</h3>
<div class="paragraph">
<p><code>Int8</code> is a signed integer represented with 8 bits. It has the range of values from -128 to 127. Integers represented with low number of bits save space in memory and also can be used to enforce supported range of values. Similar to floats, <code>Int8</code> reserves one bit to represent a positive or negative sign.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var int_8: Int8 = -20</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_uint8">5.11. UInt8</h3>
<div class="paragraph">
<p>Similar to <code>Int8</code>, <code>UInt8</code> is represented by 8 bits. However, <code>UInt8</code> is <em>unsigned</em>, meaning it represents only positive integers, including <code>0</code>. Since it represents only positive integers, the one bit that is usually reserved for sign is free to be used to represent values. Therefore, the range of <code>UInt8</code> is from 0 to 255.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var uint_8: UInt8 = 20</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_int16">5.12. Int16</h3>
<div class="paragraph">
<p><code>Int16</code> is represented with 16 bits. It has a range of values from -32,768 to 32,767.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var int_16: Int16 = -29</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_uint16">5.13. UInt16</h3>
<div class="paragraph">
<p><code>UInt16</code> is also represented with 16 bits. It has a range of values from 0 to 65,535.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var uint_16: UInt16 = 34</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_int32">5.14. Int32</h3>
<div class="paragraph">
<p><code>Int32</code> is represented with 32 bits. It has a range of values from -2,147,483,648 to 2,147,483,647.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var int_32: Int32 = -78</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_uint32">5.15. UInt32</h3>
<div class="paragraph">
<p><code>UInt32</code> is represented with 32 bits. It has a range of values from 0 to 4,294,967,295.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var uint_32: UInt32 = 87</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_int64">5.16. Int64</h3>
<div class="paragraph">
<p><code>Int64</code> is represented with 64 bits. It has a range of values from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var int_64: Int64 = -65</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_uint64">5.17. UInt64</h3>
<div class="paragraph">
<p><code>UInt64</code> is represented with 64 bits. It has a range of values from 0 to 18,446,744,073,709,551,615.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var uint_64: UInt64 = 77</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_bfloat16">5.18. BFloat16</h3>
<div class="paragraph">
<p><code>BFloat16</code> is represented with 16 bits. It is known as brain floating point. Its main use is in machine learning to increase the performance of ML algorithms.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">//TODO: Uncomment before release: include::{sourcedir}/base_types.mojo[tag=bfloat16] #</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_simd">5.19. SIMD</h3>
<div class="paragraph">
<p>SIMD standards for Single Instruction, Multiple Data. Processors that support SIMD allow for parallel processing of multiple data points using exactly the same instruction. SIMD was initially implemented for super computers but over a period of time, came to be used in desktop computers as multi media consumption on the desktops increased. The main benefit of SIMD is to perform vector and matrix operations, as many times the same operations need to be applied to many elements of those data structures.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/Users/indu/Documents/Projects/Books/books/Learn_Mojo_Programming_Language/chapters/resources/graphics/SIMD.jpeg" alt="SIMD">
</div>
</div>
<div class="paragraph">
<p>Mojo provides out of the box support for SIMD. Most of the base types mentioned above are built on top of Mojo&#8217;s SIMD type.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var simd1: SIMD[DType.int8, 4] = SIMD[DType.int8, 4](10)
    var sc: Int8 = 3
    print(simd1 * sc) </code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above code, a SIMD vector of 4 elements containing data of type Int8 is instantiated with value <code>10</code> assigned to all the elements. Then when we multiply it with a value <code>3</code>, each of the element is multiplied with that scalar, resulting in <code>[30, 30, 30, 30]</code>. On a supported hardware, just one single instruction will be applied over 4 different elements at the same time to yield the array of resulting values.</p>
</div>
</div>
<div class="sect2">
<h3 id="_dtype">5.20. DType</h3>
<div class="paragraph">
<p>In the previous example you saw the initiation of a SIMD instance by passing a data type <code>DType.int8</code>. <code>DType</code> in Mojo provides a list of data types that are supported within Mojo. One of the uses of <code>DType</code> data types is to use data types as arguments to functions. <code>DType</code> also provides some operations that help in introspecting at runtime different attributes about the data type. <code>DType</code> is particularly useful in providing compile time optimization by creating specialized code for a particular type.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    fn introspect(type: DType):
        print("Bit width:", type.bitwidth())
        print("Is signed:", type.is_signed())
    
    introspect(DType.float16) </code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example, we can write a generic function that takes any <code>DType</code> and prints its bit width and whether or not it is a signed type.</p>
</div>
</div>
<div class="sect2">
<h3 id="_type_safety">5.21. Type safety</h3>
<div class="paragraph">
<p>Let&#8217;s try something. Execute the following code in Mojo.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">def main():
    var int_value: Int = "42"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Executing the code listed above results in:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">error: cannot implicitly convert 'StringLiteral' value to 'Int' in 'var' initializer
    var int_value: Int = "42"</code></pre>
</div>
</div>
<div class="paragraph">
<p>The reason is simple. Mojo is strongly typed. When you specify that a variable has type <code>Int</code>, then it expects either <code>Int</code> values or values that can be converted to <code>Int</code>. In this particular case, we tried to pass a String literal as Integer, and Mojo compiler did not allow us to do that. If Mojo was not that strict we could end up with defects where we assume a variable of a particular type which in reality it is not. This is of particular concern in large code bases worked on by many people.</p>
</div>
<div class="paragraph">
<p>Now let&#8217;s look into the following.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">def main():
    var string_val: String = 42
    print(string_val)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code shown above compiles and runs successfully and prints <code>42</code>. The reason is a bit less obvious. The String provides an initializer that takes integer values as input argument. When Mojo compiler encounters incompatible types, but finds such an initializer, it automatically initialize with the passed in value. We will cover initializers later on.</p>
</div>
</div>
<div class="sect2">
<h3 id="_object">5.22. object</h3>
<div class="paragraph">
<p>As you have seen earlier, Mojo is quite strict about types. How about the situation when you do not yet know or do not care about the type of the variable, but still want to perform some computation? Mojo provides <code>object</code> type for such cases.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    fn add(a: object, b: object) raises -&gt; object:
        return a + b
    print(add(1, 2.5))</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you execute the above code, you would see the result <code>3.5</code> printed on screen. The reason why Mojo did not complain about the type incompatibility of arguments is that the <code>object</code> type has initializers for many builtin data types. Similar to the example mentioned above for <code>String</code>, Mojo calls the appropriate initializer in <code>object</code> corresponding to the type of the given value. If <code>object</code> does not have an initializer for a given type, then a value of that particular type cannot be assigned to variables of <code>object</code> type.</p>
</div>
<div class="paragraph">
<p>In the above case, <code>object</code> has initializers for both <code>Int</code> and <code>FloatLiteral</code>. Mojo then instantiates an <code>object</code> with <code>Int</code> and the other <code>object</code> with <code>FloatLiteral</code> as its underlying value.</p>
</div>
<div class="paragraph">
<p>In case of <code>def</code> functions, when you omit type annotations on variable, argument, return declarations, Mojo automatically assigns it the type <code>object</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_tuple">5.23. Tuple</h3>
<div class="paragraph">
<p><code>Tuple</code> in Mojo is an ordered sequence of values. A <code>Tuple</code> can have many elements of different types. Mojo uses <code>()</code> to represent <code>Tuple</code> literals in source code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var t: Tuple[Int, Bool, Float64] = (1, False, 3.5)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code listed above defines a tuple with elements 1, False and 3.5. You may have noticed that the code above defined some parameters within square brackets. We will come to it in a later chapter.</p>
</div>
<div class="paragraph">
<p>You can also get length of the tuple by using Mojo&#8217;s built in function <code>len</code> as seen below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    print(len(t))</code></pre>
</div>
</div>
<div class="paragraph">
<p>An empty tuple can be defined using just <code>()</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var e: Tuple = ()
    print(len(e))</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_listliteral">5.24. ListLiteral</h3>
<div class="paragraph">
<p>Similar to <code>Tuple</code>, Mojo also provides support for <code>ListLiteral</code>. A <code>ListLiteral</code> can have many elements of different types. Mojo uses <code>[]</code> to represent list literals in source code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var l = [2, 3.5]
    print(len(l))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code shown before defines a list with elements 1 and 3.5. Same as with Tuple some parameters are defined within square brackets, which we will cover later on.</p>
</div>
<div class="paragraph">
<p>An empty list can be defined using just <code>[]</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_dictliteral">5.25. DictLiteral</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="_documenting_your_code">6. Documenting your code</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Many software that are built today have source code that are often made up of millions of lines of code. More often than not the software is also worked upon by a large number of programmers. Such large scale development makes it difficult to understand the program without some kind of documentation the describes what it does and why it does what it does.</p>
</div>
<div class="paragraph">
<p>Mojo supports two ways of documenting code.</p>
</div>
<div class="sect2">
<h3 id="_comments">6.1. Comments</h3>
<div class="paragraph">
<p>You can define comments within Mojo source code using the symbol <code>#</code>. Mojo ignores any text that comes after the <code>#</code> until it encounters the end of line. Comments are meant for human consumption and typically explain the context of the code. Comments are discarded by the compiler and do therefore not have any run time presence.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    # This is a comment
    my_function("Hello World!") # This is an inline comment</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_docstrings">6.2. Docstrings</h3>
<div class="paragraph">
<p>One of the important type of documentation is describing what a given function does. You can use Mojo comments for this purpose, but Mojo does not distinguish such comments from the ones that are given in other parts of the source code.</p>
</div>
<div class="paragraph">
<p>Mojo does provide a facility to document functions (and other type of declarations). It is called <em>Docstring</em>. In a previous chapter it was mentioned that we can define multi line string literals in Mojo using three double or three single quotes. This type of string literals are used to define Docstring.</p>
</div>
<div class="paragraph">
<p>One requirement for a multi line string literal to be a docstring of a function is that it should be scoped within the function. If it is outside the function, then it is considered to be documentation of the outer scope element. The other requirement is that it should be the first statement in the function body. The text of the multi line string must have at least one full stop. This is because the first sentence of the Docstring is considered as summary of the document and will show up in tooling as such.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">fn my_function(text: StringLiteral):
    """
    This is a doc string summary.
    And the second line represents more details.
    """
    print(text)</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can pass the above program to Mojo&#8217;s documentation tooling to generate the documentation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>mojo doc &lt;filename&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can define file level docstring by writing docstring as the first statement of the file. Such docstring is used to document the module itself.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">"""
File level docstring.
"""
alias x = 42

fn main():
    print(x)</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_struct">7. Struct</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the previous chapter we saw the different data types supported by Mojo out of the box. But what if you wanted to implement your own data type? Mojo provides <code>struct</code> keyword for that purpose. The term "struct" was popularized by the ALGOL family of languages and is a short form for the term structure. In Mojo, struct allows one to group related values together as a single unit. Members variables of a struct must have type annotation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">struct Person:
    var first_name: String
    var last_name: String

    fn __init__(inout self):
        self.first_name = "Mickey"
        self.last_name = "Mouse"

    fn get_full_name(self) -&gt; String:
        return self.first_name + " " + self.last_name</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code shown before shows how a struct is defined within Mojo. You start with keyword <code>struct</code> and then give a name for the struct. Then you can define the member variables of the struct. Here we defined <code>first_name</code> and <code>last_name</code> strings. You can also define functions within a struct. Functions defined inside the body of a struct are known as "method". The body of the struct is indented with whitespace.</p>
</div>
<div class="paragraph">
<p>You may have noticed that we have defined a method <code><em>init</em></code>. This is the initializer or in other languages known as the constructor. In order for a struct to be used in a program, we need to define a method that initializes the struct. The main responsibility of the initializer is to setup the struct in a valid state and to ensure that all the member variables also have a valid state. If we omit the initializer, the compiler would complain that <code><em>init</em></code> is missing.</p>
</div>
<div class="paragraph">
<p>In the <code><em>init</em></code> method, the first argument is mandatory and it is named <code>self</code> by convention. It does not really matter whether you call the first argument <code>self</code> or some other name as Mojo would accept any other name. However, Mojo adopts the same convention as Python and calls the first argument <code>self</code>. It is highly recommended to follow that convention as it makes the code easier to read and understand by other programmers. The first argument also has a keyword <code>inout</code>. For <code><em>init</em></code> methods, it is mandatory to have <code>inout</code> keyword in front of the first <code>self</code> argument. It indicates to Mojo that the <code>self</code> is mutable reference. We will cover this later on in this book.</p>
</div>
<div class="paragraph">
<p>To refer to the member variables of a strut, we need to prefix the variable with <code>self.</code>. Mojo allows new variables to be defined with the same names if the scope of the variable is different. The prefix <code>self.</code> makes it possible for the Mojo compiler to determine that the struct&#8217;s member variable is being referred to and not to another variable of the same name in the function scope.</p>
</div>
<div class="paragraph">
<p>The anatomy of a struct is shown in the following diagram.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/Users/indu/Documents/Projects/Books/books/Learn_Mojo_Programming_Language/chapters/resources/graphics/Struct.jpeg" alt="Struct">
</div>
</div>
<div class="paragraph">
<p>Syntax to instantiate a struct is quite similar to a function call. In the following code listing an instance of <code>Person</code> is stored in the variable <code>client</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var client: Person = Person()
    print(client.get_full_name())</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can define initializers with additional arguments. You can also define more than one initializers. The initializers can be given arguments similar to how arguments are passed to a function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">struct Person:
    var first_name: String
    var last_name: String

    fn __init__(inout self):
        self.first_name = "Mickey"
        self.last_name = "Mouse"

    fn __init__(inout self, fname: String, lname: String): # Second initializer
        self.first_name = fname
        self.last_name = lname

    fn get_full_name(self) -&gt; String: # Instance method
        return self.first_name + " " + self.last_name

fn main():
    var client: Person = Person("Donald", "Duck") # Instantiating Person
    print(client.get_full_name()) # Calling an instance method</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_instance_methods">7.1. Instance methods</h3>
<div class="paragraph">
<p>As mentioned earlier, a struct can define methods within it. There are two types of methods. One is instance method and the other is static method. Instance methods are called on an instance of the struct. In the previous code listing, <code>get_full_name</code> is an instance method because it the first argument <code>self</code> which is the instance of the struct. It uses <code>self</code> to refer to the instance variables of the struct, for example <code>self.first_name</code>.</p>
</div>
<div class="paragraph">
<p>To call the instance method, we used the syntax <code>client.get_full_name()</code>. Note that even though <code>get_full_name</code> had an argument <code>self</code> passed to it, we do not pass that argument to <code>get_full_name</code> when we call it. What is happening here? One way to look at it is that when we call <code>client.get_full_name()</code>, behind the scene the compiler passes <code>client</code> as the first argument to <code>get_full_name</code>. This syntax is quite popular in many object oriented languages, and since Python has this syntax, Mojo also took it over.</p>
</div>
</div>
<div class="sect2">
<h3 id="_static_methods">7.2. Static methods</h3>
<div class="paragraph">
<p>What if we do not have to refer to instance variables or even other instance methods in our method, but still want to have the method scoped within the struct? In this case Mojo offers static methods. Static methods are very similar to functions and they are within the scope of the struct, but not bound to a particular <em>instance</em> of the struct. Mojo compiler can perform some optimizations to make static method invocations much faster than instance methods.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">struct Vehicle:
    var model_name: String

    fn __init__(inout self, model_name: String):
        self.model_name = model_name

    fn get_model(self) -&gt; String: 
        return self.model_name
    
    @staticmethod
    fn get_default_model() -&gt; String: 
        return "VW"

fn main():
    var v: Vehicle = Vehicle("Mercedes")
    print(v.get_model()) # Call instance method
    print(Vehicle.get_default_model()) # Call static method

    print(v.get_default_model()) # Possible, but not a good style to call static method.
    print(Vehicle.get_model(v)) # Also possible, but not a good style to call an instance method.</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the previous code listing, <code>get_default_model</code> was defined using <code>@staticmethod</code> <em>decorator</em>. We will cover decorators in detail in a later chapter. The <code>@staticmethod</code> on a method indicates to the Mojo compiler that this method should be a static method.</p>
</div>
<div class="paragraph">
<p>Static methods are called using the name of the struct itself, instead of the name of the <em>variable</em> that contains the struct&#8217;s instance. For example, in the code listing the static method was called by referring to the <code>Vehicle</code> struct directly as in <code>Vehicle.get_default_model()</code>.</p>
</div>
<div class="paragraph">
<p>It is possible to call static methods through an instance of the struct, but that style is discouraged because for a person reading the code, it is confusing.</p>
</div>
</div>
<div class="sect2">
<h3 id="_implicit_conversion">7.3. Implicit conversion</h3>
<div class="paragraph">
<p>You may have noticed that assignment <code>var x: String = "A string literal" ` works, even though we saw earlier that anything within the double quotes `""</code> is of type <code>StringLiteral</code>. The above assignment works because Mojo has support for implicit conversions.</p>
</div>
<div class="paragraph">
<p>Mojo has a very simple approach for implicit conversions. Suppose that <code>struct A</code> has an initializer that takes an argument with type of <code>StringLiteral</code>. Then when we assign a <code>StringLiteral</code> to a variable of type <code>A</code>, it implicitly calls that initializer, resulting in initialization of the variable with an instance of <code>A</code> with that given string literal passed as an argument.</p>
</div>
<div class="paragraph">
<p>The following examples makes it more clear.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">struct Vehicle:
    var model_name: String

    fn __init__(inout self, model_name: StringLiteral):
        self.model_name = model_name

    fn get_model(self) -&gt; String: 
        return self.model_name
    
fn main():
    var v: Vehicle = "Ford"
    print(v.get_model())</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_trait">8. Trait</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A struct is a concrete and instantiable type whereas a trait is an abstract type that cannot be instantiated. When we define a trait, we define a set of requirements that do not have a <strong>concrete</strong> implementation, but is intended to be <strong>implemented</strong> by a concrete type.</p>
</div>
<div class="paragraph">
<p>Traits are useful abstractions especially in large a codebase. Users of traits do not need to know what concrete struct implements a particular method, as long as the implementation conforms to the requirements given in the trait. In the following code listing, <code>Flyable</code> trait requires that whatever struct implements <code>Flyable</code> must implement <code>fly</code> method. The function <code>fly_it</code> does not know the concrete implementations <code>Bird</code> or <code>Plane</code>. It takes in its arguments a type that confirms to <code>Flyable</code>, and calls method in the <code>Flyable</code>. The actual concrete types are passed to it at the call site.</p>
</div>
<div class="paragraph">
<p>A struct implicitly conforms to a trait if it implements all the requirements for the trait. This means that we do not need to explicitly specify a confirming trait in the struct declaration; but it is a recommended practice to do so.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">trait Flyable:
    fn fly(self): ...

struct Bird(Flyable):
    fn __init__(inout self): ...
    fn fly(self): print("Soar into the sky")

struct Plane(Flyable):
    fn __init__(inout self): ...
    fn fly(self): print("Jet set go")

fn fly_it[T: Flyable](f: T):
    f.fly()

fn main():
    fly_it(Bird())
    fly_it(Plane())</code></pre>
</div>
</div>
<div class="paragraph">
<p>You may have noticed in the <code>fly_it</code> definition a square bracket with a parameter being passed within it, i.e. <code>[T: Flyable]</code>. Mojo allows values to be passed during <em>compile</em> time to a function or method. Only requirement is that the values must be passed within square brackets. Those are called <strong>parameters</strong>. In other languages, parameters and arguments to functions are interchangeable terms. However, in Mojo those are distinct terms. <em>Parameters</em> are passed during compile time to a function, while <em>arguments</em> are passed at runtime. In the above example, we have passed a compile time parameter <code>T</code> of the type <code>Flyable</code> to <code>fly_it</code>. We then used that type <code>T</code> as the type of the argument <code>f</code>, indirectly assigning <code>Flyable</code> as the type of <code>f</code>.</p>
</div>
<div class="paragraph">
<p>The anatomy of a trait and its usage in a struct is shown in the following diagram.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/Users/indu/Documents/Projects/Books/books/Learn_Mojo_Programming_Language/chapters/resources/graphics/Trait.jpeg" alt="Trait">
</div>
</div>
<div class="paragraph">
<p>A single trait can be implemented by many different types, with the condition that the type ensures that all the requirements defined in the trait is implemented by the type. A type can also inherit more than one trait, with the condition that they implement all the combined requirements from of all of those traits within the type itself.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">trait Flyable:
    fn fly(self): ...

trait Walkable:
    fn walk(self): ...

struct Bird(Flyable, Walkable):
    fn __init__(inout self): ...
    fn fly(self): print("Fly to the sky")
    fn walk(self): print("Walk on the ground")

struct Cat(Walkable):
    fn __init__(inout self): ...
    fn walk(self): print("Walk carefully")

fn main():
    Bird().fly()
    Bird().walk()
    Cat().walk()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Traits can inherit from other traits. They can also inherit multiple traits at the same time.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">trait Flyable:
    fn fly(self): ...

trait Walkable:
    fn walk(self): ...

trait WalkableFlyable(Flyable, Walkable): ...

struct Bird(WalkableFlyable):
    fn __init__(inout self): ...
    fn fly(self): print("Fly to the sky")
    fn walk(self): print("Walk on the ground")

fn main():
    Bird().fly()
    Bird().walk()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Unlike many other programming languages, Mojo allows traits to require static methods on the structs it defines.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">trait Message:
    @staticmethod
    fn default_message(): ...

struct Hello(Message):
    fn __init__(inout self): ...
    
    @staticmethod
    fn default_message(): print("Hello World")

struct Bye(Message):
    fn __init__(inout self): ...
    
    @staticmethod
    fn default_message(): print("Goodbye")

fn main():
    Hello.default_message()
    Bye.default_message()</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_control_flow">9. Control flow</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Like most other programming languages, Mojo provides control structures such as conditions and loops.</p>
</div>
<div class="sect2">
<h3 id="_if_else">9.1. <code>if</code>-<code>else</code></h3>
<div class="paragraph">
<p>The most basic control flow is <code>if</code> statement. It takes an expression that must evaluate to a boolean result. The body of the <code>if</code> will be executed if the boolean result is <code>True</code>. It is not allowed to have <code>else</code> without a corresponding <code>if</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    if x == 0:
        print("X is zero")</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, we have an <code>if</code> statement with a condition. The <code>==</code> operator checks for equality, here it checks if the variable <code>x</code> has the value <code>0</code>.</p>
</div>
<div class="paragraph">
<p>If you want to execute another body of code when the <code>if</code> expression results in <code>False</code>, you can use <code>else</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    if x == 0:
        print("X is zero")
    else:
        print("X is non-zero")</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_elif">9.2. <code>elif</code></h3>
<div class="paragraph">
<p>What if you need to check multiple conditions instead of just one? Mojo provides <code>if-elif-else</code> construct for those cases.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    if x == 0:
        print("X is zero")
    elif x &lt; 0:
        print("X is negative")
    else:
        print("X is positive")</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first <code>if</code> works same as before. The <code>elif</code> is a short form of "else if". It works similar to <code>if</code> and expects the expression to evaluate to <code>True</code> to execute its own body. One thing to note is that <code>if</code> and <code>elif</code> are mutually exclusive and the first one in the sequence of the statements to have expression value as <code>True</code> will execute its body. Therefore care must be taken to correctly order the conditions so that you don&#8217;t miss out some edge cases. It is not allowed to have <code>elif</code> without a corresponding if.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    if x == 0:
        print("X is zero")
    elif x == 0:
        print("X is zero - but this won't show up")
    elif x &lt; 0:
        print("X is negative")
    else:
        print("X is positive")</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the previous code listing, since the <code>if</code> condition already evaluated to <code>True</code>, the second <code>elif</code> will not get executed even if the expression is <code>True</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_nesting_of_if">9.3. Nesting of <code>if</code></h3>
<div class="paragraph">
<p>You can nest <code>if</code> inside another <code>if</code> or <code>else</code> or <code>elif</code>. This allows for implementation of a more complex control flow logic.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    if x &lt; 0:
        print("X is negative")
        if x &lt; -5:
            print("X is too low")
    else:
        if x == 0:
            print("X is zero")
        print("X is positive")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Too many nested conditions could impact readability of the code. In this case consider whether extracting them into separate functions improve readability.</p>
</div>
</div>
<div class="sect2">
<h3 id="_if_as_expression">9.4. <code>if</code> as expression</h3>
<div class="paragraph">
<p>The standard <code>if</code> statement spans over a minimum of 4 lines, sometimes when we just want to assign a value conditionally to a variable, it is a bit verbose. Mojo provides a shorter one line version that could be used in such cases.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var message = "X is positive" if x &gt;=0 else "X is negative"
    print(message)</code></pre>
</div>
</div>
<div class="paragraph">
<p>One thing to note here is that the order of the <code>if</code> expression is different from the usual order of <code>if</code> statements.</p>
</div>
<div class="paragraph">
<p>The anatomy of if-elif-else is shown in the following diagram.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/Users/indu/Documents/Projects/Books/books/Learn_Mojo_Programming_Language/chapters/resources/graphics/If.jpeg" alt="If">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_case">9.5. <code>case</code></h3>

</div>
<div class="sect2">
<h3 id="_while">9.6. <code>while</code></h3>
<div class="paragraph">
<p>The <code>while</code> loops allow a body of code to be executed repeatedly as long as the condition of the <code>while</code> evaluates to <code>True</code>. The moment the condition evaluates to <code>False</code>, it stops executing the code body within it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    x = 0
    while x &lt;= 5:
        print("X is: ", x)
        x = x + 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>The previous code listing will print values 0 to 5.</p>
</div>
<div class="paragraph">
<p>It is possible to add <code>else</code> clause after the <code>while</code> body. The <code>else</code> body will be executed <em>exactly once</em> when the condition of <code>while</code> evaluates to <code>False</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    x = 0
    while x &lt;= 5:
        print("X is: ", x)
        x = x + 1
    else:
        print("X is now greater than 5")</code></pre>
</div>
</div>
<div class="paragraph">
<p>The previous code listing will print "X is now greater than 5" after printing values 0 to 5.</p>
</div>
<div class="paragraph">
<p>The anatomy of a <code>while</code> loop is shown in the following diagram.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/Users/indu/Documents/Projects/Books/books/Learn_Mojo_Programming_Language/chapters/resources/graphics/While.jpeg" alt="While">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_for">9.7. <code>for</code></h3>
<div class="paragraph">
<p>Similar to <code>while</code>, <code>for</code> also provides facility to repeat a code block many times. The main difference is that <code>while</code> is based on an expression evaluating to <code>True</code> whereas <code>for</code> is based on something called an iterator.</p>
</div>
<div class="paragraph">
<p>In the most simple term, an iterator is something that returns an element when its <code><em>next</em></code> method is called. The expression that comes after <code>in</code> within the <code>for</code> loop statement must resolve to an iterable. An iterable is anything that returns an iterator when its <code><em>iter</em></code> method is called. In effect, when the <code>for</code> loop is executed, it calls the iterable&#8217;s <code><em>iter</em></code> method which returns the iterator the <code>for</code> loop works with. For each repetition of the loop, the iterator&#8217;s <code><em>next</em></code> is called and its result assigned to the variable coming before the <code>in</code> keyword. The iterator must keep track of the state so that the <code>for</code> loop advances to the next element when <code><em>next</em></code> is called.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    for i in range(0, 5):
        print(i)</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is possible to add <code>else</code> clause after the <code>for</code> body. The <code>else</code> body will be executed <em>exactly once</em> when the iteration is finished.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    for i in range(0, 5):
        print(i)
    else:
        print("i is now greater than 4")</code></pre>
</div>
</div>
<div class="paragraph">
<p>The anatomy of a <code>for</code> loop is shown in the following diagram.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/Users/indu/Documents/Projects/Books/books/Learn_Mojo_Programming_Language/chapters/resources/graphics/For.jpeg" alt="For">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_skipping_and_exiting_early_from_loops">9.8. Skipping and exiting early from loops</h3>
<div class="sect3">
<h4 id="_break">9.8.1. <code>break</code></h4>
<div class="paragraph">
<p>If you want to exit the <code>while</code> or <code>for</code> loop early (usually on some condition), then you can use <code>break</code>. This allows early exit from the loop.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    x = 0
    while x &lt;= 5:
        if x &gt; 3:
            break
        print("X is: ", x)
        x = x + 1
    
    for i in range(0, 6):
        if i &gt; 3:
            break
        print("i is: ", i)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The previous code listing will print values 0 to 3, and will exit the loop as soon as <code>x</code> is greater than 3.</p>
</div>
</div>
<div class="sect3">
<h4 id="_continue">9.8.2. <code>continue</code></h4>
<div class="paragraph">
<p>What if you wanted to skip an iteration of the loop? For this case Mojo provides you with <code>continue.</code> The <code>continue</code> keyword would skip all the statements coming after it in the <code>while</code> or <code>for</code> body for exactly one iteration of the loop.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    x = 0
    while x &lt;= 5:
        x = x + 1
        if x &lt; 3:
            continue # Skip following statements of the while block
        print("X is: ", x)

    for i in range(0, 6):
        if i &lt; 3:
            continue # Skip following statements of the while block
        print("i is: ", i)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The previous code listing will skip the <code>print</code> statement coming after it until value of <code>x</code> is greater than or equal to 3.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_error_handling">10. Error handling</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Like many other languages, Mojo has built-in support for error handling. In Mojo, an error is raised using the keyword <code>raise</code> and handled using <code>except</code>. Any function call that can potentially raise an error must be wrapped within a <code>try</code> and <code>except</code> block.</p>
</div>
<div class="paragraph">
<p>The following diagram illustrates the structure of error handling in Mojo.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/Users/indu/Documents/Projects/Books/books/Learn_Mojo_Programming_Language/chapters/resources/graphics/Error.jpeg" alt="Error">
</div>
</div>
<div class="paragraph">
<p>The following example shows how a function declares that it raises an error and how the caller of a function handles it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">fn raise_error(cond: Bool) raises:
    if cond:
        raise Error("Provided condition is True") 
    else:
        print("No error")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    try:
        raise_error(True)
    except e:
        print("Error raised:", e)</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example, an error is raised inside the function <code>raise_error</code> based on a given condition. Since an error is raised, the function must declare that in its signature. This means that any one calling the function must either handle the error raised by the function, or must re-raise it further down. In the usage example, we see that the error raised by the function is handled.</p>
</div>
<div class="paragraph">
<p>It is possible to raise a <code>String</code> as error as shown below, though in reality it automatically gets wrapped within an <code>Error</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">fn raise_str_error(cond: Bool) raises:
    if cond:
        raise "String error is allowed"
    else:
        print("No error")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    try:
        raise_str_error(True)
    except e:
        print("Error raised:", e)</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_error_propagation">10.1. Error propagation</h3>
<div class="paragraph">
<p>In the following example, we see that any function that calls another function that potentially raises an error, needs to either fully handle the error within the function itself, or declare in its own signature that it too raises an error. Unhandled errors in a called function will get propagated down.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">fn raise_call() raises: # Need to either have 'raises' in the signature, or wrap with try-except
    raise_error(True)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_finally">10.2. Finally</h3>
<div class="paragraph">
<p>The <code>finally</code> code blocks always gets executed regardless whether an error is getting propagated, or it was fully handled. The <code>finally</code> block is typically used for clean-up activities, for example, if a file is opened within a <code>try</code> block, then we must close the file within a <code>finally</code> block to ensure that even if an error is raised within the <code>try</code> block the file is always closed before the function returns. If a value is returned in <code>finally</code> and <code>try</code> or <code>except</code>, the returned value will be from <code>finally</code>. The <code>finally</code> block is optional.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    try:
        raise_error(True)
    except e:
        print("Error raised:", e)
    finally:
        print("Always executed")
    try:
        raise_error(False)
    except e:
        print("Error raised:", e)
    finally:
        print("Always executed")</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_else">10.3. Else</h3>
<div class="paragraph">
<p>In order to execute statements when no error has been raised, you can use <code>else</code> block. The <code>else</code> block is optional. The <code>else</code>
block appears after <code>except</code>, but before <code>finally</code>. The <code>else</code> block is useful for those cases where we want to isolate error raising functions that we want to handle from other code that we want to execute, but may raise their own errors.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    try:
        raise_error(False)
    except e:
        print("Error raised:", e)
    else:
        print("No exception raised.")</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_operators_and_special_methods">11. Operators and special methods</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In Mojo some functions have special naming convention, starting and ending with double underscores: "<em>_". Since they start and end with __double underscores_</em>, they are called <strong><em>dunder</em></strong> methods. These methods are treated specially by Mojo compiler. Mojo supports implementation of arithmetic and relational operators, along with special methods that support lifecycle of values.</p>
</div>
<div class="paragraph">
<p>In previous chapters, we saw many times the arithmetic and relational operators. Most of these operators can be implemented by user defined structs. Mojo provides quite a bit of flexibility in defining your own low level structs and the ability to implement these operators is part of that flexibility. Implementing an operator is as simple as implementing a function.</p>
</div>
<div class="paragraph">
<p>Many of Mojo&#8217;s built in functionality is implemented as libraries. This means that we are able to implement powerful constructs just using basic language features offered by Mojo.</p>
</div>
<div class="sect2">
<h3 id="_arithmetic_operators">11.1. Arithmetic operators</h3>
<div class="paragraph">
<p>The following sections describe the various arithmetic operators in Mojo.</p>
</div>
<div class="sect3">
<h4 id="_addition">11.1.1. Addition</h4>
<div class="paragraph">
<p>The following are the addition operators.</p>
</div>
<div class="sect4">
<h5 id="_add"><code>__add__</code></h5>
<div class="paragraph">
<p>The <code>__add__</code> stands for arithmetic addition "+" between the struct defining the method and self type or another type.</p>
</div>
</div>
<div class="sect4">
<h5 id="_radd"><code>__radd__</code></h5>
<div class="paragraph">
<p>The <code>__radd__</code> method is known as reverse addition, and is used when we try to add two values, where the first value does not have <code>__add__</code> implemented. In this case, the Mojo compiler checks if the second value has <code>__radd__</code> implemented, and it calls that one.</p>
</div>
</div>
<div class="sect4">
<h5 id="_iadd"><code>__iadd__</code></h5>
<div class="paragraph">
<p>The <code>__iadd__</code> method is called in-place addition and represents arithmetic addition "=". Even if you implement just `\\__add__` and do not implement `\\__iadd__`, the "=" operation would still work as Mojo will just use <code>__add__</code> as the fallback. However, typically <code>__add__</code> returns a new instance of the result. In case of large structs (structs with many fields), it could entail a lot of copy operations. The in-place addition can directly change the struct&#8217;s internal data, resulting in an efficient execution of the addition method. The <code>__iadd__</code> therefore does not have a return value as it updates the struct itself.</p>
</div>
<div class="paragraph">
<p>Since the struct' internal value is mutated, we need to use one of the <code>inout</code> or <code>owned</code> references of <code>self</code> in the method.</p>
</div>
<div class="paragraph">
<p>The following code listing shows the different operations. Please note that these examples are not meant for production use, as it is intentionally kept incomplete for simplicity&#8217;s sake.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">struct MyFloat:

    var val: Float16

    fn __init__(inout self, value: Float16):
        self.val = value

struct MyInt:

    var val: Int

    fn __init__(inout self, value: Int):
        self.val = value    

    fn __add__(self, other: Self) -&gt; Self:
        print("add invoked")
        return Self(self.val + other.val)

    fn __radd__(self, other: MyFloat) -&gt; Self:
        print("radd invoked")
        return Self(self.val + int(other.val))

    fn __iadd__(inout self, other: Self):
        print("iadd invoked")
        self.val = self.val + other.val</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var num: MyInt = MyInt(42)

    var add_res = MyInt(1) + MyInt(2)
    print(add_res.val)

    var radd_res = MyFloat(3.5) + MyInt(2) # Even though MyFloat does not implement __add__ method, we are able to do addition through MyInt's __radd__
    print(radd_res.val)

    var iadd_res = MyInt(10)
    iadd_res += MyInt(20)
    print(iadd_res.val)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_subtraction">11.1.2. Subtraction</h4>
<div class="paragraph">
<p>The following are the subtraction operators.</p>
</div>
<div class="sect4">
<h5 id="_sub"><code>__sub__</code></h5>
<div class="paragraph">
<p>The <code>__sub__</code> stands for arithmetic subtraction "-" between the struct defining the method and self type or another type.</p>
</div>
</div>
<div class="sect4">
<h5 id="_rsub"><code>__rsub__</code></h5>
<div class="paragraph">
<p>The <code>__rsub__</code> method is known as reverse subtraction, and is used when we try to subtract two values, where the first value does not have <code>__sub__</code> implemented. In this case, the Mojo compiler checks if the second value has <code>__rsub__</code> implemented, and it calls that one.</p>
</div>
<div class="paragraph">
<p>As the name implies, the reverse subtraction swaps the operands. Since subtraction is non-commutative, care must be taken to have  correct values as the first operand and second operands. For example, <code>x - y</code> in normal subtraction would be <code>y - x</code> in reverse subtraction.</p>
</div>
</div>
<div class="sect4">
<h5 id="_isub"><code>__isub__</code></h5>
<div class="paragraph">
<p>The <code>__isub__</code> method is called in-place subtraction and represents arithmetic subtraction "-=". The concept of <code>__isub__</code> is the same as what we saw in <code>__iadd__</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">struct MyFloat:

    var val: Float16

    fn __init__(inout self, value: Float16):
        self.val = value

struct MyInt:

    var val: Int

    fn __init__(inout self, value: Int):
        self.val = value    

    fn __sub__(self, other: Self) -&gt; Self:
        print("sub invoked")
        return Self(self.val - other.val)

    fn __rsub__(self, other: MyFloat) -&gt; Self:
        print("rsub invoked")
        return Self(int(other.val) - self.val) # Order matters for subtraction; it is not commutative. 

    fn __isub__(inout self, other: Self):
        print("isub invoked")
        self.val = self.val - other.val</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var num: MyInt = MyInt(42)

    var sub_res = MyInt(1) - MyInt(2)
    print(sub_res.val)

    var rsub_res = MyFloat(3.5) - MyInt(2) # Even though MyFloat does not implement __sub__ method, we are able to do addition through MyInt's __rsub__
    print(rsub_res.val)

    var isub_res = MyInt(10)
    isub_res -= MyInt(20)
    print(isub_res.val)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_multiplication">11.1.3. Multiplication</h4>
<div class="paragraph">
<p>The following are multiplication operators.</p>
</div>
<div class="sect4">
<h5 id="_mul"><code>__mul__</code></h5>
<div class="paragraph">
<p>The <code>__mul__</code> stands for multiplication "*" between the struct defining the method and self type or another type.</p>
</div>
</div>
<div class="sect4">
<h5 id="_rmul"><code>__rmul__</code></h5>
<div class="paragraph">
<p>The <code>__rmul__</code> method is known as reverse multiplication, and is used when we try to multiply two values, where the first value does not have <code>__mul__</code> implemented. In this case, the Mojo compiler checks if the second value has <code>__rmul__</code> implemented, and it calls that one.</p>
</div>
</div>
<div class="sect4">
<h5 id="_imul"><code>__imul__</code></h5>
<div class="paragraph">
<p>The <code>__imul__</code> method is called in-place multiplication and represents multiplication "*=". The concept of <code>__imul__</code> is the same as what we saw in <code>__iadd__</code>, except instead of addition, the applied operation is multiplication.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">struct MyFloat:

    var val: Float16

    fn __init__(inout self, value: Float16):
        self.val = value

struct MyInt:

    var val: Int

    fn __init__(inout self, value: Int):
        self.val = value    


    fn __mul__(self, other: Self) -&gt; Self:
        print("mul invoked")
        return Self(self.val * other.val)

    fn __rmul__(self, other: MyFloat) -&gt; Self:
        print("rmul invoked")
        return Self(int(other.val) * self.val) # Will truncate 

    fn __imul__(inout self, other: Self):
        print("imul invoked")
        self.val = self.val * other.val</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var num: MyInt = MyInt(42)

    var mul_res = MyInt(3) * MyInt(2)
    print(mul_res.val)

    var rmul_res = MyFloat(3.5) * MyInt(2)
    print(rmul_res.val)

    var imul_res = MyInt(10)
    imul_res *= MyInt(20)
    print(imul_res.val)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_matrix_multiplication">11.1.4. Matrix multiplication</h4>
<div class="paragraph">
<p>The following are operators for matrix multiplication.</p>
</div>
<div class="sect4">
<h5 id="_matmul"><code>__matmul__</code></h5>
<div class="paragraph">
<p>The <code>__matmul__</code> stands for matrix multiplication represented by the symbol "@" between the struct defining the method and self type or another type.</p>
</div>
</div>
<div class="sect4">
<h5 id="_rmatmul"><code>__rmatmul__</code></h5>
<div class="paragraph">
<p>The <code>__rmatmul__</code> stands for the reverse matrix multiplication represented by the symbol "@" between the struct defining the method and self type or another type. Similar to <code>__rsub__</code>, take care to use the appropriate order of the operands when doing the implementation, as the operands are swapped.</p>
</div>
</div>
<div class="sect4">
<h5 id="_imatmul"><code>__imatmul__</code></h5>
<div class="paragraph">
<p>The <code>__imatmul__</code> stands for in-place matrix multiplication represented by the symbol "@" between the struct defining the method and self type or another type. The concept of <code>__imatmul__</code> is the same as what we saw in <code>__iadd__</code>, except instead of addition, the applied operation is matrix multiplication.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">struct MyFloatMatrix:

    var val: List[List[Float16]]
    var rows: Int
    var cols: Int

    fn __init__(inout self, value: List[List[Float16]], rows: Int, cols: Int):
        self.val = value
        self.rows = rows
        self.cols = cols

    @staticmethod
    fn empty() -&gt; Self:
        return MyFloatMatrix(List[List[Float16]](), 0, 0)

struct MyIntMatrix:

    var val: List[List[Int]]
    var rows: Int
    var cols: Int

    fn __init__(inout self, value: List[List[Int]], rows: Int, cols: Int):
        self.val = value    
        self.rows = rows
        self.cols = cols
    
    @staticmethod
    fn empty() -&gt; Self:
        return MyIntMatrix(List[List[Int]](), 0, 0)

    fn print(self):
        print("....")
        print("Rows:", self.rows, "Cols:", self.cols)
        for row in self.val:
            print()
            for col in row[]:
                print(col[], end=" ")
        print()
        print("----")



    @staticmethod
    fn _matmul_internal(first: Self, second: Self) -&gt; Self:
        if first.cols != first.rows:
            print("Rows and columns do not match. ")
            return MyIntMatrix.empty()
        
        var res: List[List[Int]] = List[List[Int]](capacity=first.rows)

        for i in range(first.rows):
            res.append(List[Int](capacity=second.cols))
            for j in range(second.cols):
                var s = 0
                for k in range(first.cols):
                    s += first.val[i][k] * second.val[k][j]
                res[i].append(s)

        return Self(res, first.rows, second.cols)


    fn __matmul__(self, other: Self) -&gt; Self: # Naive implementation - not for production use
        print("matmul invoked")
        return Self._matmul_internal(self, other)

    fn __rmatmul__(self, other: MyFloatMatrix) -&gt; Self: # Naive implementation - not for production use
        print("rmatmul invoked")
        var res: List[List[Int]] = List[List[Int]](capacity=self.rows)
        for i in range(other.rows):
            res.append(List[Int](capacity=self.cols))
            for j in range(self.cols):
                var s = 0
                for k in range(other.cols):
                    s += int(other.val[i][k]) * self.val[k][j] # Will truncate 
                res[i].append(s)

        return Self(res, other.rows, self.cols)

    fn __imatmul__(inout self, other: Self): # Naive implementation - not for production use
        print("imatmul invoked")
        var res = Self._matmul_internal(self, other)
        self.val = res.val
        self.rows = res.rows
        self.cols = res.cols</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var m : List[List[Int]] = List(
            List(1, 2, 1), 
            List(5, 1, 1),
            List(2, 3, 1))
    var n: List[List[Int]] = List(
        List(2, 5),
        List(6, 7),
        List(1, 1))
    
    var flm : List[List[Float16]] = List(
            List[Float16](1.2, 2.3, 1.4), 
            List[Float16](5.2, 1.2, 1.3),
            List[Float16](2.3, 3.4, 1.4))

    var matmul_res = MyIntMatrix(m, 3, 3) @ MyIntMatrix(n, 3, 2)
    matmul_res.print()

    var rmatmul_res = MyFloatMatrix(flm, 3, 3) @ MyIntMatrix(n, 3, 2)
    rmatmul_res.print()

    var imatmul_res = MyIntMatrix(m, 3, 3)
    imatmul_res @= MyIntMatrix(n, 3, 2)
    imatmul_res.print()</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_division">11.1.5. Division</h4>
<div class="paragraph">
<p>The division operators.</p>
</div>
<div class="sect4">
<h5 id="_truediv"><code>__truediv__</code></h5>
<div class="paragraph">
<p>The <code>__truediv__</code> stands for division represented by the symbol "/" between the struct defining the method and self type or another type. The result of <code>\\__truediv</code> is a floating point type with 64 bits.</p>
</div>
</div>
<div class="sect4">
<h5 id="_rtruediv"><code>__rtruediv__</code></h5>
<div class="paragraph">
<p>The <code>__rtruediv__</code> stands for the reverse division represented by the symbol "/" between the struct defining the method and self type or another type. Similar to <code>__rsub__</code>, take care to use the appropriate order of the operands when doing the implementation, as the operands are swapped.</p>
</div>
</div>
<div class="sect4">
<h5 id="_itruediv"><code>__itruediv__</code></h5>
<div class="paragraph">
<p>The <code>__itruediv__</code> stands for in-place division represented by the symbol "/" between the struct defining the method and self type or another type. The concept of <code>__itruediv__</code> is the same as what we saw in <code>__iadd__</code>, except instead of addition, the applied operation is division.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">struct MyFloat:

    var val: Float16

    fn __init__(inout self, value: Float16):
        self.val = value

struct MyInt:

    var val: Int

    fn __init__(inout self, value: Int):
        self.val = value    


    fn __truediv__(self, other: Self) -&gt; MyFloat:
        print("truediv invoked")
        return MyFloat(self.val / other.val)

    fn __rtruediv__(self, other: MyFloat) -&gt; MyFloat:
        print("rtruediv invoked")
        return MyFloat(int(other.val) / self.val)

    fn __itruediv__(inout self, other: Self):
        print("itruediv invoked")
        self.val = int(self.val / other.val) # Will truncate </code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var num: MyInt = MyInt(42)

    var div_res = MyInt(3) / MyInt(2)
    print(div_res.val)

    var rdiv_res = MyFloat(3.5) / MyInt(2)
    print(rdiv_res.val)

    var idiv_res = MyInt(10)
    idiv_res /= MyInt(20)
    print(idiv_res.val)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that <code>__itruediv__</code> implementation had to convert the result from a <code>Float</code> to <code>Int</code> because <code>MyInt</code> can only store <code>Int</code> as value within it. Mojo has the ability to have a variable with multiple possible types through <code>Variant</code> struct. We will cover that in a later chapter.</p>
</div>
</div>
<div class="sect4">
<h5 id="_floordiv"><code>__floordiv__</code></h5>
<div class="paragraph">
<p>The <code>__floordiv__</code> stands for floor division (also known as integer division) represented by the symbol "//" between the struct defining the method and self type or another type. As the name suggest, the result of the <code>__floordiv__</code> is an integer instead of float.</p>
</div>
<div class="paragraph">
<p>Typically implementations truncate towards zero in case of positive values and away from zero for negative values. For example, <code>7//3</code> results in <code>2</code>, while <code>-7//3</code> results in <code>-3</code> and not <code>-2</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_rfloordiv"><code>__rfloordiv__</code></h5>
<div class="paragraph">
<p>The <code>__rfloordiv__</code> stands for the reverse division represented by the symbol "//" between the struct defining the method and self type or another type. Similar to <code>__rtruediv__</code>, take care to use the appropriate order of the operands when doing the implementation, as the operands are swapped.</p>
</div>
</div>
<div class="sect4">
<h5 id="_ifloordiv"><code>__ifloordiv__</code></h5>
<div class="paragraph">
<p>The <code>__ifloordiv__</code> stands for in-place division represented by the symbol "//" between the struct defining the method and self type or another type. The concept of <code>__ifloordiv__</code> is the same as what we saw in <code>__iadd__</code>, except instead of addition, the applied operation is floor division.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">struct MyFloat:

    var val: Float16

    fn __init__(inout self, value: Float16):
        self.val = value

struct MyInt:

    var val: Int

    fn __init__(inout self, value: Int):
        self.val = value    


    fn __floordiv__(self, other: Self) -&gt; Self:
        print("floordiv invoked")
        return Self(self.val // other.val)

    fn __rfloordiv__(self, other: MyFloat) -&gt; Self:
        print("rfloordiv invoked")
        return Self(int(other.val) // self.val)

    fn __ifloordiv__(inout self, other: Self):
        print("ifloordiv invoked")
        self.val = self.val // other.val  </code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var num: MyInt = MyInt(42)

    var floordiv_res = MyInt(3) // MyInt(2)
    print(floordiv_res.val)

    var rfloordiv_res = MyFloat(3.5) // MyInt(2)
    print(rfloordiv_res.val)

    var ifloordiv_res = MyInt(10)
    ifloordiv_res //= MyInt(20)
    print(ifloordiv_res.val)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_modulo">11.1.6. Modulo</h4>
<div class="paragraph">
<p>The following are the modulo operators.</p>
</div>
<div class="sect4">
<h5 id="_mod"><code>__mod__</code></h5>
<div class="paragraph">
<p>The <code>__mod__</code> stands for modulo operation represented by the symbol "%" between the struct defining the method and self type or another type. The approach to implement <code>__mod__</code> is the same as what we saw in <code>__truediv__</code>, except instead of division, the applied operation is modulo operation.</p>
</div>
<div class="paragraph">
<p>The <code>__mod__</code> derives its name from the mathematical modulo operation. Modulo operation divides two numbers and returns the remainder of the division.</p>
</div>
</div>
<div class="sect4">
<h5 id="_rmod"><code>__rmod__</code></h5>
<div class="paragraph">
<p>The <code>__rmod__</code> stands for the reverse modulo operation represented by the symbol "%" between the struct defining the method and self type or another type. Similar to <code>__rtruediv__</code>, take care to use the appropriate order of the operands when doing the implementation, as the operands are swapped.</p>
</div>
</div>
<div class="sect4">
<h5 id="_imod"><code>__imod__</code></h5>
<div class="paragraph">
<p>The <code>__imod__</code> stands for in-place modulo operation represented by the symbol "%" between the struct defining the method and self type or another type. The concept of <code>__imod__</code> is the same as what we saw in <code>__itruediv__</code>, except instead of division, the applied operation is modulo.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">struct MyFloat:

    var val: Float16

    fn __init__(inout self, value: Float16):
        self.val = value

struct MyInt:

    var val: Int

    fn __init__(inout self, value: Int):
        self.val = value    


    fn __mod__(self, other: Self) -&gt; Self:
        print("mod invoked")
        return Self(self.val % other.val)

    fn __rmod__(self, other: MyFloat) -&gt; Self:
        print("rmod invoked")
        return Self(int(other.val) % self.val)

    fn __imod__(inout self, other: Self):
        print("imod invoked")
        self.val = self.val % other.val  </code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var num: MyInt = MyInt(42)

    var mod_res = MyInt(7) % MyInt(2)
    print(mod_res.val)

    var rmod_res = MyFloat(8) % MyInt(2)
    print(rmod_res.val)

    var imod_res = MyInt(37)
    imod_res %= MyInt(20)
    print(imod_res.val)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exponentiation">11.1.7. Exponentiation</h4>
<div class="paragraph">
<p>The following lists the exponentiation operators.</p>
</div>
<div class="sect4">
<h5 id="_pow"><code>__pow__</code></h5>
<div class="paragraph">
<p>The <code>__pow__</code> stands for exponential operation represented by the symbol "**" between the struct defining the method and self type or another type. The approach to implement <code>__pow__</code> is the same as what we saw in <code>__mul__</code>, except instead of multiplication, we apply exponential operation.</p>
</div>
</div>
<div class="sect4">
<h5 id="_ipow"><code>__ipow__</code></h5>
<div class="paragraph">
<p>The <code>__ipow__</code> stands for in-place exponential operation represented by the symbol "**" between the struct defining the method and self type or another type. The concept of <code>__ipow__</code> is the same as what we saw in <code>__imul__</code>, except instead of multiplication, we apply exponential operation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">struct MyInt:

    var val: Int

    fn __init__(inout self, value: Int):
        self.val = value    


    fn __pow__(self, other: Self) -&gt; Self:
        print("pow invoked")
        return Self(self.val ** other.val)

    fn __ipow__(inout self, other: Self):
        print("ipow invoked")
        self.val **= other.val  </code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var num: MyInt = MyInt(42)

    var pow_res = MyInt(7) ** MyInt(2)
    print(pow_res.val)

    var ipow_res = MyInt(7)
    ipow_res **= MyInt(2)
    print(ipow_res.val)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_unary_operators">11.1.8. Unary operators</h4>
<div class="paragraph">
<p>The following are the unary operators.</p>
</div>
<div class="sect4">
<h5 id="_neg"><code>__neg__</code></h5>
<div class="paragraph">
<p>The <code>__neg__</code> stands for the unary operation represented by the symbol "-" for the struct defining the method. The negative sign appears as prefix to the value and typically results in negation of the value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">struct MyInt:

    var val: Int

    fn __init__(inout self, value: Int):
        self.val = value    

    fn __neg__(self) -&gt; Self:
        print("neg invoked")
        return Self(-self.val)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var num: MyInt = MyInt(42)

    var neg_res = -MyInt(7)
    print(neg_res.val)</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_pos"><code>__pos__</code></h5>
<div class="paragraph">
<p>The <code>__pos__</code> stands for the unary operation represented by the symbol "+" for the struct defining the method. The positive sign appears as prefix to the value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">struct MyInt:

    var val: Int

    fn __init__(inout self, value: Int):
        self.val = value    

    fn __pos__(self) -&gt; Self:
        print("pos invoked")
        return Self(+self.val)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var num: MyInt = MyInt(42)

    var pos_res = +MyInt(7)
    print(pos_res.val)</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_invert"><code>__invert__</code></h5>
<div class="paragraph">
<p>The <code>__invert__</code> stands for the unary operation represented by the symbol "~" for the struct defining the method. The invert sign appears as prefix to the value. Typical implementations return bitwise compliment of the value, switching <code>1</code> for <code>0</code> and vice versa.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">struct MyInt:

    var val: Int

    fn __init__(inout self, value: Int):
        self.val = value    

    fn __invert__(self) -&gt; Self:
        print("invert invoked")
        return Self(~self.val)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var num: MyInt = MyInt(42)

    var invert_res = ~MyInt(2)
    print(invert_res.val)</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_bitwise_operators">11.2. Bitwise operators</h3>
<div class="paragraph">
<p>The following are the bitwise operators.</p>
</div>
<div class="sect3">
<h4 id="_operators">11.2.1. Operators</h4>
<div class="sect4">
<h5 id="_lshift"><code>__lshift__</code></h5>
<div class="paragraph">
<p>The <code>__lshift__</code> stands for left shift operation represented by the symbol "&lt;&lt;" between the struct defining the method and self type or another type. Typical implementation shifts the bits of the first operand to the left. The second operand indicates how many bits are to be shifted to the left.</p>
</div>
</div>
<div class="sect4">
<h5 id="_rlshift"><code>__rlshift__</code></h5>
<div class="paragraph">
<p>The <code>__rlshift__</code> stands for the reverse left shift operation represented by the symbol "&lt;&lt;" between the struct defining the method and self type or another type. Similar to <code>__rtruediv__</code>, take care to use the appropriate order of the operands when doing the implementation, as the operands are swapped.</p>
</div>
</div>
<div class="sect4">
<h5 id="_ilshift"><code>__ilshift__</code></h5>
<div class="paragraph">
<p>The <code>__ilshift__</code> stands for in-place left shift operation represented by the symbol "&lt;&#8656;" between the struct defining the method and self type or another type. Typical implementation shifts the bits of the first operand to the left. The second operand indicates how many bits are to be shifted to the left. Instead of returning a new instance like in <code>__lshift__</code>, the <code>__ilshift__</code> updates its own instance with the result. The concept is similar to <code>__iadd__</code> mentioned earlier.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">struct MyFloat:

    var val: Float16

    fn __init__(inout self, value: Float16):
        self.val = value

struct MyInt:

    var val: Int

    fn __init__(inout self, value: Int):
        self.val = value    

    fn __lshift__(self, other: Self) -&gt; Self:
        print("lshift invoked")
        return Self(self.val &lt;&lt; other.val)

    fn __rlshift__(self, other: MyFloat) -&gt; Self:
        print("rlshift invoked")
        return Self(int(other.val) &lt;&lt; self.val)

    fn __ilshift__(inout self, other: Self):
        print("ilshift invoked")
        self.val &lt;&lt;= other.val</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var num: MyInt = MyInt(42)

    var lshift_res = MyInt(2) &lt;&lt; MyInt(3)
    print(lshift_res.val)

    var rlshift_res = MyFloat(2) &lt;&lt; MyInt(3)
    print(rlshift_res.val)

    var ilshift_res = MyInt(3)
    ilshift_res &lt;&lt;= MyInt(2)
    print(ilshift_res.val)</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_rshift"><code>__rshift__</code></h5>
<div class="paragraph">
<p>The <code>__rshift__</code> stands for right shift operation represented by the symbol "&gt;&gt;" between the struct defining the method and self type or another type. Typical implementation shifts the bits of the first operand to the right. The second operand indicates how many bits are to be shifted to the right.</p>
</div>
</div>
<div class="sect4">
<h5 id="_rrshift"><code>__rrshift__</code></h5>
<div class="paragraph">
<p>The <code>__rrshift__</code> stands for the reverse right shift operation represented by the symbol "&gt;&gt;" between the struct defining the method and self type or another type. Similar to <code>__rlshift__</code>, take care to use the appropriate order of the operands when doing the implementation, as the operands are swapped.</p>
</div>
</div>
<div class="sect4">
<h5 id="_irshift"><code>__irshift__</code></h5>
<div class="paragraph">
<p>The <code>__irshift__</code> stands for in-place right shift operation represented by the symbol "&gt;&gt;=" between the struct defining the method and self type or another type. Typical implementation shifts the bits of the first operand to the left. The second operand indicates how many bits are to be shifted to the left. Instead of returning a new instance like in <code>__rshift__</code>, the <code>__irshift__</code> updates its own instance with the result. The concept is similar to <code>__iadd__</code> mentioned earlier.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">struct MyFloat:

    var val: Float16

    fn __init__(inout self, value: Float16):
        self.val = value

struct MyInt:

    var val: Int

    fn __init__(inout self, value: Int):
        self.val = value    

    fn __rshift__(self, other: Self) -&gt; Self:
        print("rshift invoked")
        return Self(self.val &gt;&gt; other.val)

    fn __rrshift__(self, other: MyFloat) -&gt; Self:
        print("rrshift invoked")
        return Self(int(other.val) &gt;&gt; self.val)

    fn __irshift__(inout self, other: Self):
        print("irshift invoked")
        self.val &gt;&gt;= other.val</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var num: MyInt = MyInt(42)

    var rshift_res = MyInt(20) &gt;&gt; MyInt(3)
    print(rshift_res.val)

    var rrshift_res = MyFloat(24) &gt;&gt; MyInt(3)
    print(rrshift_res.val)

    var irshift_res = MyInt(30)
    irshift_res &gt;&gt;= MyInt(2)
    print(irshift_res.val)</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_and"><code>__and__</code></h5>
<div class="paragraph">
<p>The <code>__and__</code> stands for bitwise AND operator represented by the symbol "&amp;" between the struct defining the method and self type or another type.</p>
</div>
</div>
<div class="sect4">
<h5 id="_rand"><code>__rand__</code></h5>
<div class="paragraph">
<p>The <code>__rand__</code> stands for reverse bitwise AND operator represented by the symbol "&amp;" between the struct defining the method and self type or another type. This is invoked when the first value does not have <code>__and__</code> implemented. In this case, the Mojo compiler checks if the second value has <code>__rand__</code> implemented, and calls that one.</p>
</div>
</div>
<div class="sect4">
<h5 id="_iand"><code>__iand__</code></h5>
<div class="paragraph">
<p>The <code>__iand__</code> stands for in-place bitwise AND operator represented by the symbol "&amp;=" between the struct defining the method and self type or another type. Instead of returning a new instance like in <code>__and__</code>, the <code>__iand__</code> updates its own instance with the result.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">struct MyFloat:

    var val: Float16

    fn __init__(inout self, value: Float16):
        self.val = value

struct MyInt:

    var val: Int

    fn __init__(inout self, value: Int):
        self.val = value    

    fn __and__(self, other: Self) -&gt; Self:
        print("and invoked")
        return Self(self.val &amp; other.val)

    fn __rand__(self, other: MyFloat) -&gt; Self:
        print("rand invoked")
        return Self(int(other.val) &amp; self.val)

    fn __iand__(inout self, other: Self):
        print("iand invoked")
        self.val &amp;= other.val</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var num: MyInt = MyInt(42)

    var and_res = MyInt(23) &amp; MyInt(6)
    print(and_res.val)

    var rand_res = MyFloat(20) &amp; MyInt(4)
    print(rand_res.val)

    var iand_res = MyInt(10)
    iand_res &amp;= MyInt(2)
    print(iand_res.val)</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_or"><code>__or__</code></h5>
<div class="paragraph">
<p>The <code>__or__</code> stands for bitwise OR operator represented by the symbol "|" between the struct defining the method and self type or another type.</p>
</div>
</div>
<div class="sect4">
<h5 id="_ror"><code>__ror__</code></h5>
<div class="paragraph">
<p>The <code>__ror__</code> stands for reverse bitwise OR operator represented by the symbol "|" between the struct defining the method and self type or another type. This is invoked when the first value does not have <code>__or__</code> implemented. In this case, the Mojo compiler checks if the second value has <code>__ror__</code> implemented, and calls that one.</p>
</div>
</div>
<div class="sect4">
<h5 id="_ior"><code>__ior__</code></h5>
<div class="paragraph">
<p>The <code>__ior__</code> stands for in-place bitwise OR operator represented by the symbol "|=" between the struct defining the method and self type or another type. Instead of returning a new instance like in <code>__or__</code>, the <code>__ior__</code> updates its own instance with the result.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">struct MyFloat:

    var val: Float16

    fn __init__(inout self, value: Float16):
        self.val = value

struct MyInt:

    var val: Int

    fn __init__(inout self, value: Int):
        self.val = value    

    fn __or__(self, other: Self) -&gt; Self:
        print("or invoked")
        return Self(self.val | other.val)

    fn __ror__(self, other: MyFloat) -&gt; Self:
        print("ror invoked")
        return Self(int(other.val) | self.val)

    fn __ior__(inout self, other: Self):
        print("ior invoked")
        self.val |= other.val</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var num: MyInt = MyInt(42)

    var or_res = MyInt(5) | MyInt(3)
    print(or_res.val)

    var ror_res = MyFloat(15) | MyInt(17)
    print(ror_res.val)

    var ior_res = MyInt(5)
    ior_res |= MyInt(1)
    print(ior_res.val)</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_xor"><code>__xor__</code></h5>
<div class="paragraph">
<p>The <code>__xor__</code> stands for bitwise XOR operator represented by the symbol "^" between the struct defining the method and self type or another type.</p>
</div>
</div>
<div class="sect4">
<h5 id="_rxor"><code>__rxor__</code></h5>
<div class="paragraph">
<p>The <code>__rxor__</code> stands for reverse bitwise XOR operator represented by the symbol "^" between the struct defining the method and self type or another type. This is invoked when the first value does not have <code>__xor__</code> implemented. In this case, the Mojo compiler checks if the second value has <code>__rxor__</code> implemented, and calls that one.</p>
</div>
</div>
<div class="sect4">
<h5 id="_ixor"><code>__ixor__</code></h5>
<div class="paragraph">
<p>The <code>__ixor__</code> stands for in-place bitwise OR operator represented by the symbol "^=" between the struct defining the method and self type or another type. Instead of returning a new instance like in <code>__xor__</code>, the <code>__ixor__</code> updates its own instance with the result.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">struct MyFloat:

    var val: Float16

    fn __init__(inout self, value: Float16):
        self.val = value

struct MyInt:

    var val: Int

    fn __init__(inout self, value: Int):
        self.val = value    

    fn __xor__(self, other: Self) -&gt; Self:
        print("xor invoked")
        return Self(self.val ^ other.val)

    fn __rxor__(self, other: MyFloat) -&gt; Self:
        print("rxor invoked")
        return Self(int(other.val) ^ self.val)

    fn __ixor__(inout self, other: Self):
        print("ixor invoked")
        self.val ^= other.val</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var num: MyInt = MyInt(42)

    var xor_res = MyInt(5) ^ MyInt(3)
    print(xor_res.val)

    var rxor_res = MyFloat(15) ^ MyInt(17)
    print(rxor_res.val)

    var ixor_res = MyInt(5)
    ixor_res ^= MyInt(3)
    print(ixor_res.val)</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_relational_operators">11.3. Relational operators</h3>
<div class="sect3">
<h4 id="_operators_2">11.3.1. Operators</h4>
<div class="sect4">
<h5 id="_eq"><code>__eq__</code></h5>
<div class="paragraph">
<p>The <code>__eq__</code> stands for equality operator represented by the symbol "==" between the struct defining the method and self type or another type. The operation returns a <code>Bool</code> value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">struct MyInt:

    var val: Int

    fn __init__(inout self, value: Int):
        self.val = value    

    fn __eq__(self, other: Self) -&gt; Bool:
        print("eq invoked")
        return self.val == other.val</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var num: MyInt = MyInt(42)

    print(MyInt(5) == MyInt(5))
    print(MyInt(5) == MyInt(3))</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_ne"><code>__ne__</code></h5>
<div class="paragraph">
<p>The <code>__ne__</code> stands for inequality operator represented by the symbol "!=" between the struct defining the method and self type or another type. The operation returns a <code>Bool</code> value. Note that <code>__ne__</code> is not invoked when you call <code>not x==y</code> though.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">struct MyInt:

    var val: Int

    fn __init__(inout self, value: Int):
        self.val = value    

    fn __ne__(self, other: Self) -&gt; Bool:
        print("ne invoked")
        return self.val != other.val</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var num: MyInt = MyInt(42)

    print(MyInt(5) != MyInt(5))
    print(MyInt(5) != MyInt(3))
    print(not MyInt(5) == MyInt(3))</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_lt"><code>__lt__</code></h5>
<div class="paragraph">
<p>The <code>__lt__</code> stands for less-than operator represented by the symbol "&lt;" between the struct defining the method and self type or another type. The operation returns a <code>Bool</code> value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">struct MyInt:

    var val: Int

    fn __init__(inout self, value: Int):
        self.val = value    

    fn __lt__(self, other: Self) -&gt; Bool:
        print("lt invoked")
        return self.val &lt; other.val</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var num: MyInt = MyInt(42)

    print(MyInt(5) &lt; MyInt(5))
    print(MyInt(3) &lt; MyInt(5))</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_gt"><code>__gt__</code></h5>
<div class="paragraph">
<p>The <code>__gt__</code> stands for greater-than operator represented by the symbol "&gt;" between the struct defining the method and self type or another type. The operation returns a <code>Bool</code> value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">struct MyInt:

    var val: Int

    fn __init__(inout self, value: Int):
        self.val = value    

    fn __gt__(self, other: Self) -&gt; Bool:
        print("gt invoked")
        return self.val &gt; other.val</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var num: MyInt = MyInt(42)

    print(MyInt(5) &gt; MyInt(5))
    print(MyInt(5) &gt; MyInt(3))</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_le"><code>__le__</code></h5>
<div class="paragraph">
<p>The <code>__le__</code> stands for less-than-or-equal-to operator represented by the symbol "&#8656;" between the struct defining the method and self type or another type. The operation returns a <code>Bool</code> value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">struct MyInt:

    var val: Int

    fn __init__(inout self, value: Int):
        self.val = value    

    fn __le__(self, other: Self) -&gt; Bool:
        print("le invoked")
        return self.val &lt;= other.val</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var num: MyInt = MyInt(42)

    print(MyInt(5) &lt;= MyInt(5))
    print(MyInt(5) &lt;= MyInt(3))</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_ge"><code>__ge__</code></h5>
<div class="paragraph">
<p>The <code>__ge__</code> stands for greater-than-or-equal-to operator represented by the symbol "&gt;=" between the struct defining the method and self type or another type. The operation returns a <code>Bool</code> value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">struct MyInt:

    var val: Int

    fn __init__(inout self, value: Int):
        self.val = value    

    fn __ge__(self, other: Self) -&gt; Bool:
        print("ge invoked")
        return self.val &gt;= other.val</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var num: MyInt = MyInt(42)

    print(MyInt(5) &gt;= MyInt(5))
    print(MyInt(3) &gt;= MyInt(5))</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_index_operators">11.4. Index operators</h3>
<div class="paragraph">
<p>Any large scale program would use collection data types such as lists, arrays, dictionaries extensively. Some programming languages have built-in syntax to make usage of such types convenient. Mojo has built-in syntactical support for collection types. Mojo allows accessing collection like data types using the syntax <code>[]</code>. For example, <code>list[2]</code>. It also allows setting of values at a given index (e.g. list[2]=5).
In line with Mojo&#8217;s philosophy of moving as much functionality as possible to libraries, instead of having specially treated data types that have exclusive privilege of syntax, Mojo opened up the index operator capability to any type that defines <code>__getitem__</code> and <code>__setitem__</code> methods. This means that your custom <code>List</code> struct will have the same syntactical support like the <code>List</code> bundled with Mojo.</p>
</div>
<div class="sect3">
<h4 id="_operators_3">11.4.1. Operators</h4>
<div class="sect4">
<h5 id="_getitem"><code>__getitem__</code></h5>
<div class="paragraph">
<p>The <code>__getitem__</code> is the method invoked when you try to access values stored within the collection using the <code>my_list[index]</code> syntax (where <code>my_list</code> is the collection and <code>index</code> is the position of the element desired from the list).</p>
</div>
</div>
<div class="sect4">
<h5 id="_setitem"><code>__setitem__</code></h5>
<div class="paragraph">
<p>The <code>__setitem__</code> is the method invoked when you try to assign values to a collection using the <code>my_list[index]=value</code> syntax (where <code>my_list</code> is the collection and <code>index</code> is the position at which the value will be assigned).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">struct MyCollection:
    var list: List[String]

    fn __init__(inout self, list: List[String]):
        self.list = list

    fn __getitem__(self, x: Int) -&gt; String:
        return self.list[x] 

    fn __setitem__(inout self, x: Int, val: String):
        self.list[x] = val</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var x = MyCollection(List(String("A"), String("B")))
    print("Before:", x[1]) # Gets
    x[1] = String("C") # Sets
    print("After:", x[1])</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is also possible to get and set using multiple indices, especially useful for Matrix like data structures. This means that we can use in our code <code>my_list[row, col, and so on&#8230;&#8203;]</code>.</p>
</div>
<div class="paragraph">
<p>The following code listing shows such an example for a matrix. Note that this example is not a production quality implementation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">struct MyMatrix:

    var val: List[List[String]]
    var rows: Int
    var cols: Int

    fn __init__(inout self, rows: Int, cols: Int):
        self.rows = rows
        self.cols = cols
        self.val = List[List[String]](capacity=rows)
        for row in range(rows):
            self.val.append(List[String](capacity=cols))
            for col in range(cols):
                self.val[row].append(String("None"))
    
    fn __getitem__(self, row: Int, col: Int) -&gt; String:
        return self.val[row][col]
    
    fn __setitem__(inout self, row: Int, col: Int, s: String):
        self.val[row][col] = s</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var y = MyMatrix(5, 3)
    print("Before:", y[1, 2]) # Gets
    y[1, 2] = String("D") # Sets
    print("After:", y[1, 2])</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_context_management_methods">11.5. Context management methods</h3>
<div class="paragraph">
<p>In large programs, we often need to resources like files and database connections. When we open access to those resources, we typically have a handle, which we use to perform actions. However, once we have done with our actions, we must remember to cleanup or close the resources, otherwise we end up with dangling resources, memory leaks, locked files, etc. Mojo provides <code>with</code> keyword for managing such context or resources.</p>
</div>
<div class="paragraph">
<p>The following diagram illustrates the syntax of the <code>with</code> statement.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/Users/indu/Documents/Projects/Books/books/Learn_Mojo_Programming_Language/chapters/resources/graphics/With.jpeg" alt="With">
</div>
</div>
<div class="sect3">
<h4 id="_methods">11.5.1. Methods</h4>
<div class="sect4">
<h5 id="_enter"><code>__enter__</code></h5>
<div class="paragraph">
<p>The method that handles the allocation of the resource and returns a resource. The resource has scope only within the body of the <code>with</code>. It is not mandatory to assign the return value to a variable, especially if it is not being used.</p>
</div>
</div>
<div class="sect4">
<h5 id="_exit"><code>__exit__</code></h5>
<div class="paragraph">
<p>The method that handles the cleanup of the resource. There are two implementations of the <code>__exit__</code> method, one without any arguments <code>__exit__(self, Error)</code> and one with <code>Error</code> as an argument <code>__exit__(self, Error)</code>. The <code>__exit__(self, Error)</code> is invoked when the <code>with</code> body has an exception and exits the <code>with</code> block abnormally. The method <code>__exit__(self, Error)</code> returns a <code>Bool</code> to indicate whether or not to propagate the error further.</p>
</div>
<div class="paragraph">
<p>Any resources allocated in the <code>__enter__</code> must be cleaned up at both the <code>__exit__</code> methods, otherwise we would end up with dangling resources. For example, if <code>__exit__(self, Error)</code> is not properly implemented, resource leaks will occur only when there are exceptions raised within the <code>with</code> body. This will lead to rare but difficult to find defects.</p>
</div>
<div class="paragraph">
<p>The following code listing shows an example for the context manager.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">struct Resource:

    var name: String

    fn __init__(inout self, name: String):
        self.name = name

    fn open(self): 
        print("Opened")

    fn close(self): 
        print("Close")

    fn __copyinit__(inout self, other:Resource): 
        self.name = other.name

struct MyResourceManager:

    var resource: Resource
    fn __init__(inout self): 
        self.resource = Resource("a_resource")

    fn __enter__(self) -&gt; Resource:
        print("Entered context")
        self.resource.open()
        return self.resource
    
    fn __exit__(self):
        self.resource.close()
        print("Exited context")

    fn __exit__(self, err: Error) -&gt; Bool:
        self.resource.close()
        print("Exited context")
        return False</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    with MyResourceManager() as res:
        print("Inside context, resource is:", res.name)
        raise Error("An error while processing")</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_other_special_methods">11.6. Other special methods</h3>
<div class="sect3">
<h4 id="_methods_2">11.6.1. Methods</h4>
<div class="sect4">
<h5 id="_len"><code>__len__</code></h5>
<div class="paragraph">
<p>The <code>__len__</code> is defined within <code>Sized</code> trait and is used by the built-in <code>len</code> function. The <code>__len__</code> method returns the length or size of the struct implementing it.</p>
</div>
</div>
<div class="sect4">
<h5 id="_int_2"><code>__int__</code></h5>
<div class="paragraph">
<p>The <code>__int__</code> is defined within <code>Intable</code> trait and is used by the built-in <code>int</code> function. The <code>__int__</code> method returns an integer representation of the struct implementing it.</p>
</div>
</div>
<div class="sect4">
<h5 id="_bool_2"><code>__bool__</code></h5>
<div class="paragraph">
<p>The <code>__bool__</code> is defined within <code>Boolable</code> trait and is used by conditional statements such as <code>if</code> to convert the given value to a boolean value for evaluation. The <code>__bool__</code> method returns a boolean representation of the struct implementing it.</p>
</div>
</div>
<div class="sect4">
<h5 id="_str"><code>__str__</code></h5>
<div class="paragraph">
<p>The <code>__str__</code> is defined within <code>Stringable</code> trait and is used by the built-in <code>str</code> function. The <code>__str__</code> method returns an string representation of the struct implementing it. The built-in function <code>print</code> uses <code>__str__</code> before it prints the given value.</p>
</div>
<div class="paragraph">
<p>The following code listing provides examples of special methods.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">struct MyStruct(Sized, Intable, Boolable, Stringable):

    var ints: List[Int]

    fn __init__(inout self, ints: List[Int]):
        self.ints = ints
    
    fn __len__(self) -&gt; Int:
        print("len called")
        return len(self.ints)
    
    fn __int__(self) -&gt; Int:
        print("int called")
        var sum: Int = 0
        for i in range(len(self.ints)):
            sum += self.ints[i]
        return sum
    
    fn __bool__(self) -&gt; Bool:
        print("bool called")
        return len(self.ints)&gt;0
    
    fn __str__(self) -&gt; String:
        print("str called")
        return "MyStruct"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var st = MyStruct(List(1, 2, 3))
    print(len(st))
    print(int(st))
    if st: # Uses __bool__
        print("MyStruct is true")
    print(str(st))
    print(st) # Can directly print st because the __str__ method is implemented</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_is"><code>__is__</code></h5>
<div class="paragraph">
<p>The <code>__is__</code> method is used by the <code>is</code> clause to compare the identity between two values, and returns <code>True</code> if the identities are the same. Note that it is different from the <code><em>eq</em></code> method. The <code><em>eq</em></code> compares if two values are the same content-wise, while <code><em>is</em></code> checks if the two values are having the same identities. This means that two objects may have exactly same content, but different identities. Typical implementations check if the memory location of the two values are the same, in which case it would be considered as being identical.</p>
</div>
</div>
<div class="sect4">
<h5 id="_isnot"><code>__isnot__</code></h5>
<div class="paragraph">
<p>The <code>__isnot__</code> method is used by the <code>is not</code> clause to compare the identity between two values, and returns <code>True</code> if the identities are <strong>not</strong> the same. It is the opposite of the <code>is</code> clause, and in most cases it is sufficient for the implementation to return a negation of the <code><em>is</em></code> method.</p>
</div>
<div class="paragraph">
<p>The following code listing provides examples of <code><em>is</em></code> and <code><em>isnot</em></code> methods.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">struct MyStruct:

    var ptr: UnsafePointer[Int]

    fn __init__(inout self, ptr: UnsafePointer[Int]): 
        self.ptr = ptr

    fn __is__(self, other: MyStruct) -&gt; Bool:
        print("__is__ called")
        return self.ptr == other.ptr

    fn __isnot__(self, other: MyStruct) -&gt; Bool:
        print("__isnot__ called")
        return not(self is other)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var x: Int = 10
    var y: Int = 10
    print(MyStruct(UnsafePointer.address_of(x)) is MyStruct(UnsafePointer.address_of(y))) # Results in False
    print(MyStruct(UnsafePointer.address_of(x)) is MyStruct(UnsafePointer.address_of(x))) # Results in True
    print(MyStruct(UnsafePointer.address_of(x)) is not MyStruct(UnsafePointer.address_of(y))) # Results in True</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lifecycle_and_ownership">12. Lifecycle and ownership</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Before we jump into the lifecycle operations, let&#8217;s understand the concept of ownership of references.</p>
</div>
<div class="sect2">
<h3 id="_pass_by_value_and_pass_by_reference">12.1. Pass by value and pass by reference</h3>
<div class="paragraph">
<p>We have two ways to pass something to a function or method. One is pass by value and the other is pass by reference.</p>
</div>
<div class="paragraph">
<p>We call something as passed by value when the actual value of a variable is passed to the function, which results in the value being <strong>copied</strong> to the callee function&#8217;s argument. In this case the callee has its own copy and the caller has another copy. If the callee function changes the value, it is not reflected in the caller. In Mojo the data types that fit within the registers of the CPU are passed by default as values and so the callee gets a copy of the value. Also, when we perform an assignment of a variable to another variable, the value of the variable is copied to the assignee.</p>
</div>
<div class="paragraph">
<p>The second way is to pass the location where the value is stored. In this case, both the caller and the callee refers to the exact same location of the value. We can say that the caller is passing a reference to the value to the callee. So if the callee changes the value, that change will be reflected immediately in the caller.</p>
</div>
<div class="paragraph">
<p>When we pass a value by reference to a function, that function can potentially change the value. However, if the caller is not expecting its value to be changed while the callee changes the value, we end up with defects. In many programming languages that support pass by reference, it is a common source of defects. So how can we indicate to the caller of a function that the function intends to only read the value or it intends to change it? Mojo provides a solution by annotating the function arguments with a set of keywords that shows the intend.</p>
</div>
</div>
<div class="sect2">
<h3 id="_borrowed">12.2. borrowed</h3>
<div class="paragraph">
<p>The borrowed keyword indicates that the argument is used only to read the value and the argument&#8217;s value will not be changed. This is the default behavior of all <code>fn</code> function&#8217;s arguments, so the <code>borrowed</code> keyword is not necessary to be given.</p>
</div>
<div class="paragraph">
<p>When an argument is borrowed, the Mojo compiler prevents any mutation of the argument&#8217;s value. It also does not allow the binding of the argument to be changed as it would have led to discarding (and destruction) of the original value contained in the argument. Since we are borrowing the value, the caller would not expect the value to be destroyed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">fn value_borrowed(borrowed val: Int):
    ...
fn value(val: Int): # This is also borrowed
    ...</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_owned">12.3. owned</h3>
<div class="paragraph">
<p>The <code>owned</code> keyword indicates that the function assumes the ownership of the given reference argument. This means that we are free to mutate or destruct the passed value within that function. This is the default behavior of all <code>def</code> function&#8217;s arguments, so the <code>owned</code> keyword is not necessary to be given for <code>def</code> functions.</p>
</div>
<div class="paragraph">
<p>When an argument is owned, the function can be sure that it can mutate the argument. It is possible that Mojo passes a copy of the value to the function in such cases. When the value is copied, then the caller has own copy and the callee function has its own copy.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">fn value_owned(owned val: Int):
    ...</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_inout">12.4. inout</h3>
<div class="paragraph">
<p>The <code>inout</code> keyword indicates that the function will potentially mutate the value within the passed reference. The difference from <code>owned</code> references is that the <code>inout</code> arguments are implicitly returned by the function. That is, the function cannot return an uninitialized <code>inout</code> argument. If the value within the <code>inout</code> reference is destructed, then another value must be assigned to the argument before the function returns.</p>
</div>
<div class="paragraph">
<p>To move a reference, the caret <code>^</code> operator is used.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">fn value_inout(inout val: Int):
    ...

fn value_inout_return(inout val: String):
    _ = val^ # Effectively destruct the value. Now the reference is uninitialized
    val = 10 # We have to assign a value otherwise Mojo compiler would complain</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s now look into the lifecycle methods. We start with one that we are already familiar with: the <code><em>init</em></code> method.</p>
</div>
</div>
<div class="sect2">
<h3 id="_init">12.5. <code>__init__</code></h3>
<div class="paragraph">
<p>The init method is part of the lifecycle of a struct. The main purpose of <code><em>init</em></code> is to initialize all its member variables (a.k.a fields).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">struct MyNumber:

    var value_ptr: UnsafePointer[Int]

    fn __init__(inout self, value: Int):
        self.value_ptr = UnsafePointer[Int].alloc(1)
        initialize_pointee_move(self.value_ptr, value)

    fn value(self) -&gt; Int:
        return self.value_ptr[]

    fn change_value(self, value: Int):
        initialize_pointee_move(self.value_ptr, value)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var num: MyNumber = MyNumber(42)
    print("num:", num.value())</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, we defined a <code>struct</code> and the <code><em>init</em></code> method within it. The first argument of the <code><em>init</em></code> method is always <code>self</code> with a modifier <code>inout</code>. The <code>self</code> is a reference to the struct&#8217;s own instance. The <code>inout</code> tells the compiler that the <code>self</code> is mutable (i.e., we can change the field values held within <code>self</code>). In Mojo, the function arguments are <em>by default read-only</em>, and we cannot change the values of the function argument. The <code>inout</code> is needed for <code>self</code> so that we are able to initialize the fields within the struct. Since one of the main responsibility of <code><em>init</em></code> is to initialize the fields of the struct, we naturally need to mark it as <code>inout</code>.</p>
</div>
<div class="paragraph">
<p>In the example, we are allocating memory from the heap to store an integer value using the static method call <code>UnsafePointer[Int].alloc</code>. We store a value into the pointer location using the function <code>initialize_pointee_move</code>. We retrieve the stored value from the pointer using the deference operator <code>[]</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_del">12.6. <code>__del__</code></h3>
<div class="paragraph">
<p>The delete method <code><em>del</em></code> is also part of the lifecycle of a struct. If the init method is used to initialize variables or to allocate resources for that struct, the delete method is used to release the resources held for that struct. For example, if init method allocates memory from the heap, the delete method is used to free that memory. The <code><em>del</em></code> method is called just before the value is going to be destroyed by the compiler. If we allocate resources in the init method and do not release or free those resources in the delete method, we end up with resource leaks such as memory leaks. So great care must be taken to symmetrically allocate and free resources using the init and delete methods.</p>
</div>
<div class="paragraph">
<p>Unlike many other languages, Mojo has an eager destruction approach. This means that a value or object is destroyed as soon as its last use, unless its lifetime is explicitly extended. This is in contrast with many system languages where the values or objects are destroyed at the end of the scope of a given block. This approach allowed Mojo to have a much simpler lifecycle management, improving overall ergonomics of the language.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">struct MyNumber:

    var value_ptr: UnsafePointer[Int]

    fn __init__(inout self, value: Int):
        self.value_ptr = UnsafePointer[Int].alloc(1)
        initialize_pointee_move(self.value_ptr, value)

    fn value(self) -&gt; Int:
        return self.value_ptr[]

    fn change_value(self, value: Int):
        initialize_pointee_move(self.value_ptr, value)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    fn __del__(owned self):
        self.value_ptr.free()</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var num: MyNumber = MyNumber(42)
    print("num:", num.value())</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_copyinit">12.7. <code>__copyinit__</code></h3>
<div class="paragraph">
<p>Mojo invokes the <code><em>copyinit</em></code> for all the cases where a value needs to be copied. For example, when a variable is assigned to another one, the <code><em>copyinit</em></code> may be called for the assignee. This method is quite similar to the <code><em>init</em></code> method in the sense that it initializes the struct. In contrast to <code><em>init</em></code>, <code><em>copyinit</em></code> gets an additional argument of the same type as the struct in which the method is declared (the type of itself is named as <code>Self</code> in Mojo). In the <code><em>copyinit</em></code> it is expected that you initialize your member fields with values copied from the "other" struct. <code><em>copyinit</em></code> is also known as copy constructor in other languages.</p>
</div>
<div class="paragraph">
<p>Mojo compiler tries to optimize away copies as much as possible, especially where the reference is not being used later on.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">struct MyNumber:

    var value_ptr: UnsafePointer[Int]

    fn __init__(inout self, value: Int):
        self.value_ptr = UnsafePointer[Int].alloc(1)
        initialize_pointee_move(self.value_ptr, value)

    fn value(self) -&gt; Int:
        return self.value_ptr[]

    fn change_value(self, value: Int):
        initialize_pointee_move(self.value_ptr, value)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    fn __copyinit__(inout self, other: Self):
        self.value_ptr = UnsafePointer[Int].alloc(1)
        initialize_pointee_copy(self.value_ptr, other.value())</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var num: MyNumber = MyNumber(42)
    print("num:", num.value())</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var other_num: MyNumber = num # Calling __copyinit__ on other_num
    print("other_num after copy:", other_num.value())
    other_num.change_value(84)
    print("other_num after change:", other_num.value())
    print("num after copy:", num.value())</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the previous code listing, within the <code><em>copyinit</em></code>, we are allocating new memory for holding the copy of the value from <code>other</code>. The <code>other</code> has type <code>Self</code>, which means the same type as the struct defining the <code><em>copyinit</em></code> - in this case <code>MyNumber</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_moveinit">12.8. <code>__moveinit__</code></h3>
<div class="paragraph">
<p>Mojo invokes the <code><em>moveinit</em></code> for all the cases where a value needs to be moved. This method is quite similar to the <code><em>init</em></code> method in the sense that it initializes the struct. In contrast to <code><em>copyinit</em></code>, <code><em>moveinit</em></code> has the second argument annotated with <code>owned</code>. The <code>owned</code> is required because the second argument&#8217;s value will be destroyed once the move operation completes. In <code><em>moveinit</em></code>, we reassign the values from the <code>other</code> struct to the struct which defines the <code><em>moveinit</em></code>.</p>
</div>
<div class="paragraph">
<p><code><em>moveinit</em></code> is particularly useful where copy operations are expensive. For example, in Mojo move semantics are used for <code>String</code>. This ensures that string operations are as much as possible efficient, while still maintaining immutability.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    fn __moveinit__(inout self, owned other: Self):
        self.value_ptr = other.value_ptr
        other.value_ptr = UnsafePointer[Int]()</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var num: MyNumber = MyNumber(42)
    print("num:", num.value())</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var other_num2: MyNumber = num^ # Moving
    print("other_num2 after move:", other_num2.value())
    other_num2.change_value(84)
    print("other_num2 after change:", other_num2.value())
    # Uncommenting below line results in compiler error as `num` is no longer initialized
    #print("num after copy:", num.value())</code></pre>
</div>
</div>
<div class="paragraph">
<p>The different lifecycle operations are illustrated in the following diagram.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/Users/indu/Documents/Projects/Books/books/Learn_Mojo_Programming_Language/chapters/resources/graphics/Lifecycle.jpeg" alt="Lifecycle">
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_parameters_and_compile_time_programming">13. Parameters and compile-time programming</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_compile_time_execution_of_code">13.1. Compile-time execution of code</h3>
<div class="paragraph">
<p>The programs we write are compiled by the compiler and then an executable file is created out of it. This executable file is later run on an operating system. So the code we write is executed when we run the program. So if we write a loop, then that loop gets executed when the program is run. Let&#8217;s imagine that we need to execute a function for which the inputs are well known already at the time of writing the code. Such a function can be executed at compile-time, and the results kept in the executable file. This means that when the program is run, it just takes the pre-calculated value, saving valuable CPU time during the execution.</p>
</div>
<div class="paragraph">
<p>Unlike many mainstream languages, Mojo allows execution of code at compile-time. Mojo even has very few restrictions on what kind of code can be executed at compile-time.</p>
</div>
<div class="paragraph">
<p>We already saw the use of <code>alias</code> to store a constant. When we assign a function&#8217;s value to an <code>alias</code> constant, Mojo executes that function at compile-time and assigns the result as a constant value to the <code>alias</code>.</p>
</div>
<div class="paragraph">
<p>For example see the following code listing.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">fn add(a: Int, b: Int) -&gt; Int: 
    return a + b</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">alias added = add(1, 2)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    print(added)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_conditional_execution_at_compile_time">13.2. Conditional execution at compile-time</h3>
<div class="paragraph">
<p>We can conditionally call a function, or define a constant. That is, the <code>if</code> statement also can be used at compile time. Mojo allows us to pass an environment variable at compile time, which we can access and conditionally compile our code.  To pass an environment variable to the compiler, you can use the option <code>-D &lt;var&gt;=&lt;val&gt;</code>.
For example, <code>mojo -D add_it=True filename.mojo</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">fn add(a: Int, b: Int) -&gt; Int: 
    return a + b</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo"># Execute with "mojo -D add_it=True &lt;filename&gt;" for a non-zero value
alias added_conditionally = add(1, 2) if is_defined["add_it"]() else 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    print(added_conditionally)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_in_functions">13.3. Parameters in functions</h3>
<div class="paragraph">
<p>We saw that we can use <code>alias</code> to execute functions at compile time. What if we do not want to execute the function at compile-time, but just "parameterize" the function at compile-time, so that when it is finally run during the program execution, it uses that passed-in parameters? Mojo provides a solution to that by providing capability for compile-time parameterization. To achieve this, we pass <strong>parameters</strong> within <strong>square brackets</strong>. For example: <code>add[my_param: Int]()</code>. So in short, when we want to pass to a function values at <strong>runtime</strong>, we pass it within <strong>parenthesis</strong>, and if we want to pass to a function values at <strong>compile-time</strong>, we pass it within <strong>square brackets</strong>. Note that we are distinguishing between parameters and arguments. In Mojo parameters are compile-time values and arguments are runtime values.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">fn add[cond: Bool](a: Int, b: Int) -&gt; Int: 
    return a + b if cond else 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    # Execute with "mojo -D add_it=True &lt;filename&gt;" for a non-zero value
    print(add[is_defined["add_it"]()](3, 4))</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the previous example, we are passing a boolean value as a parameter to the <code>add</code> function. The value of the boolean is taken from a compile-time command line argument <code>add_it</code> using the Mojo option <code>-D</code>. The compiler will hardcode <code>True</code> in the parameter <code>cond</code> of the function <code>add</code> if the <code>add_it</code> was set (the value of the <code>add_it</code> is irrelevant here). Irrespective of where and how the compiled file is executed, the <code>cond</code> will have a constant value set at the compile-time.</p>
</div>
<div class="paragraph">
<p>In addition to values being passed as parameters to functions, we can also pass types themselves. If a concrete struct is expected in the parameter, then Mojo expects a <strong>value</strong> to be passed at the function call site. However, if a trait is expected in the parameter, then Mojo expects a <strong>type</strong> to be passed at the function call site.</p>
</div>
<div class="paragraph">
<p>In the previous example we saw that <code>add</code> expected a value of type <code>Bool</code>. In the next example, the <code>add_ints</code> expects a trait <code>Intable</code> as a parameter. That trait is then later used to declare the types of the function arguments. At the function call site, you can see that <code>Int</code> is being passed as parameter.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">fn add_ints[IntType: Intable](a: IntType, b: IntType) -&gt; Int: 
    return int(a) + int(b)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    print(add_ints[Int](3, 4))</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_keyword_parameters">13.4. Keyword parameters</h3>
<div class="paragraph">
<p>So far we have seen how we can pass parameters by position. Similar to the keyword arguments that we pass to functions, we can pass parameter values using the name of the parameter. The rules of the keyword parameters are the same as the keyword arguments for functions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">fn div_compile_time[a: Int, b: Int]() -&gt; Float64: 
    return a / b</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    print(div_compile_time[b=3, a=4]())</code></pre>
</div>
</div>
<div class="paragraph">
<p>The previous example shows that we can pass parameter values with the param names, in which case the order of the parameters is not relevant.</p>
</div>
</div>
<div class="sect2">
<h3 id="_variadic_parameters">13.5. Variadic parameters</h3>
<div class="paragraph">
<p>Sometimes we want to be able to pass any number of parameters, without being restricted to a particular number of parameters. When we prefix a parameter with <code>*</code>, Mojo allows us to pass any number of values to it.</p>
</div>
<div class="paragraph">
<p>The following is an example of positional variadic parameters:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">fn add_all[*a: Int]() -&gt; Int: 
    var result: Int = 0
    for i in VariadicList(a):
        result+= i
    return result</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    print(add_all[1, 2, 3]())</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example, we can see that at the function call site, we can pass any number of parameters since the function definition prefixes its parameter <code>a</code> with a <code>*</code>. The function definition then iterates over the <code>a</code> after wrapping it in a <code>VariadicList</code> and calculates the sum.</p>
</div>
</div>
<div class="sect2">
<h3 id="_default_values_in_parameters">13.6. Default values in parameters</h3>
<div class="paragraph">
<p>Mojo allows default values to be used for parameters.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">fn sub[cond: Bool = False](a: Int, b: Int) -&gt; Int: 
    return a + b if cond else 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    print(sub(3, 4)) # Default value is taken
    print(sub[True](3, 4)) # Override the default value</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example, we have assigned a default value for parameter <code>cond</code>, which allow us to make the call to <code>sub</code> without passing any value to the parameter <code>cond</code>, effectively making the parameter <code>cond</code> an optional parameter. This makes for ergonomic APIs using sensible defaults wherever it is possible.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_in_structs_traits">13.7. Parameters in structs, traits</h3>
<div class="paragraph">
<p>Similar to functions, we can also pass compile-time parameters to structs, traits.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">trait IntCopy(Intable, Copyable): pass

struct MyStruct[T: IntCopy, cond: Bool]:
    var value: T

    fn __init__(inout self, value: Int):
        self.value = value

    fn get_value(self) -&gt; Int:
        return int(self.value) if cond else 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    print(MyStruct[Int, True](10).get_value())
    print(MyStruct[Int, False](11).get_value())</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can also have keyword parameters for structs, and traits.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    print(MyStruct[cond=True, T=Int](10).get_value())</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the previous example, the parameters were passed and processed similar to how we did in functions. Basically, what we can do with parameters for functions, we can do the same for structs, and traits.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_advanced_usage_of_functions">14. Advanced usage of functions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In previous chapters you saw how we declare types of variables and how we use them. In Mojo you can assign also a function to a variable. The type of the variable is determined by the function&#8217;s signature, i.e., it is a combination of the argument types and return type of the function.</p>
</div>
<div class="paragraph">
<p>In the following code listing, you can see the variable <code>my_fn_var</code> is of type <code>fn(Int, Int) &#8594; Int</code> and is assigned a function with the same signature as the type of <code>my_fn_var</code>. Another thing to note is that the assigned function does not have the trailing <code>()</code> which is usual in a function call. This is because we are not calling the function <code>adder</code>, instead we are binding the function to the variable <code>my_fn_var</code>. In fact, we do <strong>not</strong> want to call <code>adder</code> at that point of time.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">fn adder(a: Int, b: Int) -&gt; Int: 
    return a + b</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var my_fn_var: fn(Int, Int) -&gt; Int = adder
    print(my_fn_var(4, 3))</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example, we see that we defined a function <code>adder</code> and then assigned that function to a variable. We later execute that variable as if it is a function.</p>
</div>
<div class="sect2">
<h3 id="_higher_order_functions">14.1. Higher-order functions</h3>
<div class="paragraph">
<p>The ability to assign a function to a variable allows us to implement some interesting use cases. We can pass a function as an argument to another function. We can also return a function as the result from another function. A function that can take a function as an argument, or can return a function as the result is called a higher-order function.</p>
</div>
<div class="paragraph">
<p>There are some interesting uses of higher-order functions, such as the ability to define generic functions that takes any function as an argument and executes the given function based on some condition, or inside a loop, and so on.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">fn adder(a: Int, b: Int) -&gt; Int: 
    return a + b

fn suber(a: Int, b: Int) -&gt; Int: 
    return a - b

fn exec(x: Int, y: Int, bin_op: fn(Int, Int) -&gt; Int) -&gt; Int:
    var result: Int = 0
    for i in range(10):
        result += bin_op(x, y)
    return result</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    print(exec(10, 5, adder))
    print(exec(10, 5, suber))</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this code listing we see that the function <code>exec</code> is a higher-order function that takes another function as argument. The <code>exec</code> function executes the passed-in function within a loop to calculate a result. We can pass two different functions to the same <code>exec</code> function, and the <code>exec</code> will treat both the passed functions the same way. In this way we have built a generic function that does not need to know what the passed-in does, instead it just executes them and calculates results.</p>
</div>
<div class="paragraph">
<p>Functions can also passed as parameters to another function. The main difference is that the functions are then passed at compile-time instead of at runtime.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">fn diver(a: Int, b: Int) -&gt; Float16: 
    return a / b

fn exec_param[bin_op: fn(Int, Int) -&gt; Int](x: Int, y: Int) -&gt; Int:
    var result: Int = 0
    for i in range(10):
        result += bin_op(x, y)
    return result</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    print(exec_param[adder](10, 5))
    print(exec_param[suber](10, 5))</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_closure">14.2. Closure</h3>
<div class="paragraph">
<p>So far we have seen that we can pass arguments to functions and they would use those arguments within their body. There is another technique for functions to get values from outside of the function body, which is commonly known as closure.</p>
</div>
<div class="paragraph">
<p>In a closure, we define a function that captures values outside of its function body. The values that are captured must be defined before the definition of the function itself. Another constraint is that the data type of the captured values must implement <code>__copyinit__</code>, as the value of the variable is <strong>copied</strong> over to the function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">fn exec_rt_closure(x: Int, bin_op_cl: fn(Int) escaping -&gt; Int) -&gt; Int:
    var result: Int = 0
    for i in range(10):
        result += bin_op_cl(x)
    return result</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var rt_y: Int = 5
    fn ander(x: Int) -&gt; Int: 
        return x &amp; rt_y
    print(exec_rt_closure(12, ander))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The closure shown above is known as a runtime closure. The type of the closure is <code>fn() escaping &#8594; T</code>. Note that the captured values are owned by the closure. Runtime closure can be passed as argument to other functions.</p>
</div>
<div class="paragraph">
<p>However, the runtime closure <strong>cannot</strong> be passed as a <strong>parameter</strong> to other functions. In order to pass a closure as a parameter to other functions, we need to use a compile-time closure. Such closures are decorated by <code>@parameter</code>. The type of the closure is <code>fn() capturing &#8594; T</code>. The following example demonstrates such a compile-time closure.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">fn exec_ct_closure[bin_op_cl: fn(Int) capturing -&gt; Int](x: Int) -&gt; Int:
    var result: Int = 0
    for i in range(10):
        result += bin_op_cl(x)
    return result</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    var ct_y: Int = 10
    @parameter
    fn multer(x: Int) -&gt; Int: 
        return x * ct_y
    print(exec_ct_closure[multer](10))</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_variadic_function">14.3. Variadic function</h3>
<div class="paragraph">
<p>You have already seen how the built-in <code>print</code> function is able to take any number of arguments. This is possible because of Mojo&#8217;s support for variadic functions. The variadic argument is prefixed by <code><strong></code> for positional arguments and <code></strong>*</code> for keyword arguments. Data type of positional variadic argument is <code>VariadicList[T]</code> and of keyword variadic argument is <code>Dict[K, V]</code>.</p>
</div>
<div class="paragraph">
<p>The following is an example of positional variadic arguments:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">fn add_all(*a: Int) -&gt; Int: 
    var result: Int = 0
    for i in a:
        result+= i
    return result</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage of positional variadic arguments:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    print(add_all(1, 2, 3, 4, 5))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is an example of keyword variadic arguments:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">fn names_dob(**namedobs: String) raises: 
    for name in namedobs.keys():
        print(name[], namedobs[name[]])</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage of keyword variadic arguments:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    names_dob(ik="4/4/78", pk="5/5/84", ani="6/5/13", ad="24/5/15")</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the examples shown, the <code>add_all</code> has exactly one argument prefixed by <code>*</code>. The argument <code>a</code> is then iterated over and its elements extracted to calculate the sum. In case of the function <code>names_dob</code>, the argument <code>namedobs</code> is iterated over to print both the key name and the value associated with the key. Note that the key of the <code>Dict</code> is a <code>Reference</code> and therefore needs to be dereferenced.</p>
</div>
<div class="paragraph">
<p>Variadic arguments makes it possible to provide easy-to-use APIs by allowing any number of arguments to be passed directly to the function instead of having to wrap them up in a list or dictionary.</p>
</div>
</div>
<div class="sect2">
<h3 id="_overloading">14.4. Overloading</h3>
<div class="paragraph">
<p>There is a saying among programmers that naming is hard. For example, a function to add two numbers would be best called <code>add</code>. However, we may need to add two integers, one integer and a float, and so on. In some programming languages, that would have resulted in convoluted names such as <code>add_ints</code>, <code>add_int_float</code> and so on. Thankfully, Mojo provides a feature called function overloading. This feature allows us to define the same name to multiple functions as long as their argument types, parameter types or number of arguments are different. If two functions have the same argument types but have different result types, Mojo would complain as overloading is supported only for arguments and parameter types.</p>
</div>
<div class="paragraph">
<p>The following is an example of overloading by different argument types:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">fn add(a: Int, b:Int) -&gt; Int:
    return a + b

fn add(a: Int, b:Float16) -&gt; Int:
    return int(a + b)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage of the overloaded functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    print(add(1, 2))
    print(add(3, 2.4))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is an example of overloading by different parameter types:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">fn add[a: Int, b:Int]() -&gt; Int:
    return a + b

fn add[a: Bool, b: Bool]() -&gt; Int:
    var ai: Int = 1 if a else 0
    var bi: Int = 1 if b else 0
    return ai + bi</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage of the overloaded functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    print(add[1, 2]())
    print(add[True, False]())</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is an example of overloading by different number of arguments, even with the same type of arguments:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">fn sub(a: Int, b:Int) -&gt; Int:
    return a - b

fn sub(a: Int, b:Int, c:Int) -&gt; Int:
    return a - b - c</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usage of the overloaded functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="mojo">    print(sub(1, 2))
    print(sub(1, 2, 3))</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_about_the_author">About the author</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Indukumar has more than 25 years of experience in software development, architecture and management. During his career he has designed and developed many applications in different domains, ranging from travel portals to financial product management systems.</p>
</div>
<div class="paragraph">
<p>Indukumar Vellapillil Hari resides in Zurich, Switzerland with his family.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_revision_history">Revision History</h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">First Release</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Aug 1, 2025</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Copyright &#169; 2025 Indukumar Vellapillil Hari</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2024-05-15 20:20:07 +0200
</div>
</div>
</body>
</html>